{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SIPI Documentation","text":"<p>Welcome to the documentation for SIPI (Simple Image Presentation Interface).</p>"},{"location":"#user-guide","title":"User Guide","text":"<ul> <li>Overview \u2014 What SIPI is and what it does</li> <li>Introduction \u2014 IIIF concepts and SIPI use cases</li> <li>Reference \u2014 IIIF URL syntax, CLI options, configuration parameters</li> <li>Running \u2014 CLI usage, server mode, logging, exit codes</li> </ul>"},{"location":"#lua-scripting","title":"Lua Scripting","text":"<ul> <li>Lua Integration \u2014 Server API, scripting, request handling</li> <li>Lua Image Functions \u2014 Image manipulation from Lua</li> <li>SQLite \u2014 Database access from Lua scripts</li> </ul>"},{"location":"#development","title":"Development","text":"<ul> <li>Building \u2014 Build instructions</li> <li>Developing \u2014 Development guide</li> </ul>"},{"location":"#release-notes","title":"Release Notes","text":"<ul> <li>Release Notes \u2014 Version history</li> </ul>"},{"location":"development/building/","title":"Building SIPI from Source Code","text":""},{"location":"development/building/#prerequisites","title":"Prerequisites","text":""},{"location":"development/building/#kakadu-jpeg-2000","title":"Kakadu (JPEG 2000)","text":"<p>To build SIPI from source code, you must have Kakadu, a JPEG 2000 development toolkit that is not provided with SIPI and must be licensed separately. The Kakadu source code archive <code>v8_5-01382N.zip</code> must be placed in the <code>vendor</code> subdirectory of the source tree before building.</p>"},{"location":"development/building/#adobe-icc-color-profiles","title":"Adobe ICC Color Profiles","text":"<p>SIPI uses the Adobe ICC Color profiles, which are automatically downloaded by the build process. The user is responsible for reading and agreeing with Adobe's license conditions, which are specified in the file <code>Color Profile EULA.pdf</code>.</p>"},{"location":"development/building/#building-with-docker-recommended","title":"Building with Docker (Recommended)","text":"<p>The simplest way to build SIPI is using Docker. This requires Docker with buildx support.</p> <p>All commands are run from the repository root via <code>make</code>:</p> <pre><code># Build Docker image (compiles SIPI, runs unit tests inside container)\nmake docker-build\n\n# Run smoke tests against the locally built Docker image\nmake test-smoke\n</code></pre> <p>The Docker build uses a pre-built base image (<code>daschswiss/sipi-base</code>) that includes all system dependencies. The <code>Dockerfile</code> handles cmake configuration, compilation, unit testing, and debug symbol extraction in a multi-stage build.</p>"},{"location":"development/building/#platform-specific-builds-used-by-ci","title":"Platform-specific builds (used by CI)","text":"<pre><code># Build for specific architectures (used in CI release pipeline)\nmake docker-test-build-amd64\nmake docker-test-build-arm64\n</code></pre>"},{"location":"development/building/#building-with-nix-native-development","title":"Building with Nix (Native Development)","text":"<p>For native development, SIPI uses Nix to provide a reproducible development environment with all required dependencies.</p>"},{"location":"development/building/#setup","title":"Setup","text":"<ol> <li>Install Nix</li> <li>Place the Kakadu archive <code>v8_5-01382N.zip</code> in the <code>vendor/</code> directory</li> <li>Enter the Nix development shell:</li> </ol> <pre><code># GCC environment (default, used by CI)\nnix develop\n\n# Clang environment (alternative)\nnix develop .#clang\n</code></pre>"},{"location":"development/building/#build-and-test","title":"Build and Test","text":"<p>All <code>nix-*</code> targets must be run from inside a Nix development shell:</p> <pre><code># Build SIPI (debug mode with code coverage enabled)\nmake nix-build\n\n# Run unit tests\nmake nix-test\n\n# Run end-to-end tests\nmake nix-test-e2e\n\n# Run all three in sequence (as CI does)\nmake nix-build &amp;&amp; make nix-test &amp;&amp; make nix-test-e2e\n</code></pre>"},{"location":"development/building/#run-the-server","title":"Run the Server","text":"<pre><code># Start SIPI with the default config\nmake nix-run\n</code></pre>"},{"location":"development/building/#code-coverage","title":"Code Coverage","text":"<pre><code># Generate XML coverage report (gcovr, used by CI/Codecov)\nmake nix-coverage\n\n# Generate HTML coverage report (lcov, for local viewing)\nmake nix-coverage-html\n</code></pre>"},{"location":"development/building/#debugging","title":"Debugging","text":"<pre><code># Run SIPI with Valgrind for memory leak detection\nmake nix-valgrind\n</code></pre>"},{"location":"development/building/#building-on-macos-not-recommended","title":"Building on macOS (Not Recommended)","text":"<p>Building directly on macOS without Nix is unsupported but possible:</p> <pre><code>mkdir -p ./build-mac &amp;&amp; cd build-mac &amp;&amp; cmake .. &amp;&amp; make &amp;&amp; ctest --verbose\n</code></pre> <p>You will need CMake, a C++23-compatible compiler, and all system dependencies (OpenSSL, libcurl, libmagic) installed via Homebrew.</p>"},{"location":"development/building/#all-make-targets","title":"All Make Targets","text":"<p>Run <code>make help</code> to see all available targets:</p> <pre><code>make help\n</code></pre> <p>Key target groups:</p> Target Description <code>docker-build</code> Build Docker image locally <code>docker-test-build-{amd64,arm64}</code> Build + test for specific architecture <code>test-smoke</code> Run smoke tests against Docker image <code>nix-build</code> Build SIPI natively (debug + coverage) <code>nix-test</code> Run unit tests <code>nix-test-e2e</code> Run end-to-end tests <code>nix-coverage</code> Generate XML coverage report <code>nix-run</code> Run SIPI server <code>nix-valgrind</code> Run with Valgrind <code>docs-build</code> Build documentation <code>docs-serve</code> Serve documentation locally <code>clean</code> Remove build artifacts"},{"location":"development/building/#documentation","title":"Documentation","text":"<pre><code># Build documentation site\nmake docs-build\n\n# Serve documentation locally for preview\nmake docs-serve\n\n# Serve doxygen API docs (must build with cmake first)\nmake nix-doxygen-serve\n</code></pre>"},{"location":"development/developing/","title":"Developing SIPI","text":""},{"location":"development/developing/#using-an-ide","title":"Using an IDE","text":""},{"location":"development/developing/#clion","title":"CLion","text":"<p>If you are using the CLion IDE, note that code introspection in the CLion editor may not work until it has run CMake. Open the project root directory (which contains <code>CMakeLists.txt</code>) and let CLion configure the project automatically.</p> <p>For Nix-based development, launch CLion from inside the Nix shell so it inherits all required environment variables and dependencies:</p> <pre><code>nix develop\nclion .\n</code></pre>"},{"location":"development/developing/#writing-tests","title":"Writing Tests","text":"<p>We use two test frameworks: GoogleTest for unit tests and pytest for end-to-end tests.</p>"},{"location":"development/developing/#unit-tests","title":"Unit Tests","text":"<p>Unit tests live in <code>test/unit/</code> and use GoogleTest with ApprovalTests. Tests are organized by component:</p> <ul> <li><code>test/unit/configuration/</code> - Configuration parsing tests</li> <li><code>test/unit/iiifparser/</code> - IIIF URL parser tests</li> <li><code>test/unit/sipiimage/</code> - Image processing tests</li> <li><code>test/unit/logger/</code> - Logger tests</li> <li><code>test/unit/handlers/</code> - HTTP handler tests</li> </ul> <p>Run all unit tests:</p> <pre><code>make nix-test\n</code></pre> <p>Run a specific test binary directly:</p> <pre><code>cd build &amp;&amp; test/unit/iiifparser/iiifparser\n</code></pre>"},{"location":"development/developing/#end-to-end-tests","title":"End-to-End Tests","text":"<p>End-to-end tests live in <code>test/e2e/</code> and use pytest. To add tests, create a Python file whose name begins with <code>test_</code> in the <code>test/e2e/</code> directory. The test fixtures in <code>test/e2e/conftest.py</code> handle starting and stopping a SIPI server and provide other testing utilities.</p> <p>Run e2e tests:</p> <pre><code>make nix-test-e2e\n</code></pre>"},{"location":"development/developing/#smoke-tests","title":"Smoke Tests","text":"<p>Smoke tests live in <code>test/smoke/</code> and run against a Docker image. They verify basic server functionality after a Docker build:</p> <pre><code>make test-smoke\n</code></pre>"},{"location":"development/developing/#approval-tests","title":"Approval Tests","text":"<p>Approval tests live in <code>test/approval/</code> and use snapshot-based testing for regression detection.</p>"},{"location":"development/developing/#commit-message-schema","title":"Commit Message Schema","text":"<p>We use Conventional Commits:</p> <pre><code>type(scope): subject\nbody\n</code></pre> <p>Types:</p> <ul> <li><code>feat</code> - new feature (SemVer minor)</li> <li><code>fix</code> - bug fix (SemVer patch)</li> <li><code>docs</code> - documentation changes</li> <li><code>style</code> - formatting, no code change</li> <li><code>refactor</code> - refactoring production code</li> <li><code>test</code> - adding or refactoring tests</li> <li><code>build</code> - changes to build system or dependencies</li> <li><code>chore</code> - miscellaneous maintenance</li> <li><code>ci</code> - continuous integration changes</li> <li><code>perf</code> - performance improvements</li> </ul> <p>Breaking changes are indicated with <code>!</code>:</p> <pre><code>feat!: remove deprecated API endpoint\n</code></pre> <p>Example:</p> <pre><code>feat(HTTP server): support more authentication methods\n</code></pre>"},{"location":"guide/","title":"Overview","text":"<p>SIPI is a multithreaded, high-performance, IIIF compatible media server developed by the Data and Service Center for the Humanities at the University of Basel. It is designed to be used by archives, libraries, and other institutions that need to preserve high-quality images while making them available online.</p> <p>SIPI implements the Image API 3.0 of the International Image Interoperability Framework (IIIF), and efficiently converts between image formats, preserving metadata contained in image files. In particular, if images are stored in JPEG 2000 format, SIPI can convert them on the fly to formats that are commonly used on the Internet. SIPI offers a flexible framework for specifying authentication and authorization logic in Lua scripts, and supports restricted access to images, either by reducing image dimensions or by adding watermarks. It can easily be integrated with Knora. In addition SIPI preserves most of the EXIF, IPTC and XMP metadata and can preserve or transform ICC color profiles.</p> <p>In addition, a simple webserver is integrated. The server is able to serve most common file types. In addition Lua scripts and embedded Lua (i.e., Lua embedded into HTML pages using the tags &lt;lua&gt;\u2026&lt;/lua&gt; are supported.</p> <p>SIPI can also be used from the command line to convert images to/from TIFF, JPEG 2000, JPEG, PNG, and WebP formats. For all these conversions, SIPI tries to preserve all embedded metadata such as - IPTC - EXIF - XMP - ICC color profiles. However, due to the limitations of some file formats, it cannot be guaranteed that all metadata and ICC profiles are preserved. - JPEG2000 (J2k) does not allow all types of ICC profiles   profiles. Unsupported profile types will be added to the J2k header as comment and will be reinstated if the J2k file is converted back to the TIFF-format.</p> <p>SIPI is a free software, released under the GNU Affero General Public License. It is written in C++ and runs on Linux and macOS. Note: In order to compile SIPI, the user has to provide a licensed source of the kakadu software.</p> <p>SIPI runs on Linux (including Debian, Ubuntu, and CentOS) and macOS.</p> <p>Freely distributable binary releases are available as Docker images: daschswiss/sipi.</p>"},{"location":"guide/introduction/","title":"Simple Image Presentation Interface (SIPI) - Introduction","text":""},{"location":"guide/introduction/#what-is-sipi","title":"What is SIPI?","text":""},{"location":"guide/introduction/#1-a-iiif-image-api-v3-level-2-conformant-image-server","title":"1. A IIIF Image API V3 level 2 conformant image server","text":"<ul> <li>SIPI is a full multithreaded, high performance, level2 compliant IIIF Image API 3.0 written in C++. For the   JPEG2000 implementation, it relies on the commercial kakadu-library, but otherwise it is   completely open source on GitHub. It offers special support for multipage PDFs   (through a SIPI-specific extensions to the IIIF Image API).</li> <li>SIPI has been designed for the long term preservation of images, intended for the needs of the cultural heritage field. Thus it offers   some unique features for this purpose:</li> <li>all file format conversions try to preserve all metadata (EXIF, XMP, IPTC etc.). These functionality is based     on the open source exiv2 library.</li> <li>SIPI can deal with and convert ICC color profiles based on the littlecms library.</li> <li>SIPI can embed important preservation data such as the checksum of the pixel values, original filename etc. in the file     headers.</li> <li>it supports SSL (https://\u2026)</li> <li>SIPI embeds the scripting language LUA that allows a very flexible, highly customizable    deployment that can be adapted to the enviroment SIPI is being used in. Before serving any request, a configurable   LUA script (\"pre flight script\") is being executed that can check access rights, restrictions or other stuff. SIPI LUA   has been extended with many SIPI-specific functions (including image conversion, HTTP-client etc.)</li> </ul>"},{"location":"guide/introduction/#2-an-ordinary-http-webserver","title":"2. An ordinary HTTP webserver","text":"<ul> <li>SIPI is also a normal webserver that is able to deliver arbitrary files. It also implements LUA embedded into HTML   pages.</li> <li>Using SIPI LUA scripts and routing, RESTful interfaces may be implemented. E.g. image upload and conversions may   by supported.</li> </ul>"},{"location":"guide/introduction/#3-an-image-format-conversion-tool","title":"3. An image format conversion tool","text":""},{"location":"guide/introduction/#generic-format-conversions","title":"Generic format conversions","text":"<ul> <li>image format conversion are supported between TIFF, JPEG2000, JPG and PNG. SIPI can   be used either as standalone command line tool or in server mode using LUA scripting.</li> <li>SIPI preserves most embedded metadata (EXIF, IPTC, TIFF, XMP) and is preserving and/or converting ICC color profiles.</li> </ul>"},{"location":"guide/introduction/#preservation-metadata-sipi-specific","title":"Preservation metadata (SIPI specific)","text":"<ul> <li>SIPI is able to add SIPI specific metadata to most file formats. These metadata are relevant for long-term   preservation and include the following information:<ul> <li><code>original filename</code>: The original file name before conversion</li> <li><code>original mimetype</code>: The mimetype of the original image before conversion</li> <li><code>pixel checksum</code>: A checksum (e.g. SHA-256) of the original pixel values. This checksum can be used to verify that   a format conversion didn't alter the image content.</li> <li><code>icc profile</code>: (optional) The raw ICC profile as binary string. This field is added if the destination file      format has no standard way to embed ICC color profiles (e.g. JPEG).</li> </ul> </li> </ul>"},{"location":"guide/introduction/#4-integrated-sqlite3-database","title":"4. Integrated sqlite3 Database","text":"<p>SIPI has an integrated sqlite3 database that can be used with special LUA extensions. Thus, SIPI can be used as a standalone media server with extended functionality. The sqlite3 database may be used to store metadata about images, user data etc.</p>"},{"location":"guide/introduction/#who-is-behind-sipi","title":"Who is behind SIPI?","text":"<p>SIPI is developed and maintained by Lukas Rosenthaler, professor for Digital Humanities at the University of Basel, in collaboration with the \"Data and Service Center for the Humanities\" (DaSCH.</p>"},{"location":"guide/introduction/#how-to-get-sipi","title":"How to get SIPI?","text":"<ul> <li>The easiest way is to use the docker image provided on dockerhup daschswiss/sipi.   The dockerized version has the binary kakadu library compiled in.</li> <li>You can compile SIPI from the sources on github. Since SIPI uses many   third-party open source libraries, compiling Yourself is tedious and my be frustrating (but possible). You have to   provide the licensed source of kakadu by Yourself. See kakadu software on how to get a   licensed version of the kakadu code. SIPI should compile on Linux (Ubuntu) and Apple OS X.</li> </ul>"},{"location":"guide/introduction/#sipi-as-iiif-server","title":"SIPI as IIIF-Server","text":""},{"location":"guide/introduction/#extensions-to-the-iiif-standard","title":"Extensions to the IIIF-Standard","text":""},{"location":"guide/introduction/#preflight-script","title":"Preflight script","text":"<ul> <li>Before executing a IIIF request, a freely configurable LUA-script is being called. This script must return the   permission to access the resource (\"allow\", \"restrict\" \"deny\") and the final path to the resource. This allows   to handle access rights etc. Within the LUA-script, permission databases etc. may be accessed through RESTful   services or using the internal SQLite database. In addition, the path to the resource may be redirected or other   limitations imposed (size, watermark etc.).</li> <li>The preflight script has access to the full HTTP(s) header including cookies and Authorization information. There are   also utility functions to decode JSON Web Tokens (JWT).</li> </ul>"},{"location":"guide/introduction/#access-to-non-image-files","title":"Access to non-image files","text":"<p>Sometimes it would be helpful to deliver non-image files such as XML, CSV etc. from the same directory tree as the IIIF-conformant images: - The url to download a file must have the form <code>http(s)://{server}/{prefix}/{fileid}/file</code>. The clause   /file at the end indicates that the file should bypass any IIIF URl processing and just be served as file. - Also in this case, a preflight script may be configured to control access to such file resources. - if the url has the form <code>http(s)://{server}/{prefix}/{fileid}/info.json</code>, SIPI returns a JSON containing   information about the file. The JSON has the from:   <pre><code>{\n  \"@context\": \"http://sipi.io/api/file/3/context.json\",\n  \"id\": \"https://localhost:1025/images/csv_test.csv\",\n  \"internalMimeType\": \"text/csv\",\n  \"fileSize\": 36\n}\n</code></pre>   Please note that SIPI determines the mimetype using the magic number. Due to the limitations thereof the mimetype - may not be determined exactly.</p>"},{"location":"guide/running/","title":"Running SIPI","text":"<p>SIPI can be run either as a command-line image converter or as an IIIF media server.</p>"},{"location":"guide/running/#quick-start-with-docker","title":"Quick Start with Docker","text":"<pre><code>docker run -p 1024:1024 daschswiss/sipi\n</code></pre>"},{"location":"guide/running/#running-sipi-as-a-command-line-image-converter","title":"Running SIPI as a Command-line Image Converter","text":"<p>Convert an image file to another format:</p> <pre><code>sipi --format jpg -f input.tif output.jpg\n</code></pre> <p>Query image file information:</p> <pre><code>sipi --query input.tif\n</code></pre> <p>Compare two image files pixel-wise:</p> <pre><code>sipi --compare file1.tif file2.jpg\n</code></pre>"},{"location":"guide/running/#running-sipi-as-a-server","title":"Running SIPI as a Server","text":"<pre><code>sipi --config config/sipi.config.lua\n</code></pre>"},{"location":"guide/running/#logging","title":"Logging","text":"<p>SIPI uses two logging modes depending on how it is running:</p> <ul> <li> <p>CLI mode (<code>--file</code>, <code>--compare</code>, <code>--query</code>): Plain text output.   Errors go to stderr, informational messages go to stdout.   This is the standard Unix convention for command-line tools.</p> </li> <li> <p>Server mode (<code>--config</code>): JSON-formatted log lines go to stdout.   This follows container best practices \u2014 Docker, Kubernetes, and log   collectors (Grafana Loki, Fluentd) expect structured logs on stdout.   Each line is a JSON object: <code>{\"level\": \"INFO\", \"message\": \"...\"}</code>.</p> </li> </ul>"},{"location":"guide/running/#log-levels","title":"Log Levels","text":"<p>SIPI supports the following log levels (in order of increasing severity):</p> Level Description <code>DEBUG</code> Detailed diagnostic information. <code>INFO</code> Normal operational messages (routes added, server started, migrations). <code>NOTICE</code> Significant but normal events. <code>WARNING</code> Something unexpected but recoverable (e.g., failed XMP parse, incomplete metadata write). <code>ERR</code> Errors that affect a specific operation (e.g., image processing failure, ICC error). <code>CRIT</code> Critical errors. <code>ALERT</code> Conditions requiring immediate attention. <code>EMERG</code> System-wide emergencies. <p>The log level controls which messages are emitted. Setting a level suppresses all messages below it. For example, <code>WARNING</code> shows only WARNING, ERR, CRIT, ALERT, and EMERG \u2014 suppressing DEBUG, INFO, and NOTICE.</p> <p>The log level can be configured in three ways (in order of precedence):</p> <ol> <li>CLI option: <code>--loglevel WARNING</code></li> <li>Environment variable: <code>SIPI_LOGLEVEL=WARNING</code></li> <li>Lua config: <code>loglevel = \"WARNING\"</code> (in the <code>sipi</code> block)</li> </ol> <p>If none is specified, the default level is <code>INFO</code>.</p>"},{"location":"guide/running/#command-line-options","title":"Command-line Options","text":""},{"location":"guide/running/#image-conversion-options","title":"Image Conversion Options","text":"Flag Short Description <code>--file &lt;path&gt;</code> <code>-f</code> Input file to be converted. Usage: <code>sipi [options] -f infile outfile</code> <code>--format &lt;fmt&gt;</code> <code>-F</code> Output format: <code>jpx</code>, <code>jp2</code>, <code>jpg</code>, <code>tif</code>, <code>png</code>, <code>webp</code>, <code>gif</code> <code>--icc &lt;profile&gt;</code> <code>-I</code> Convert to ICC profile: <code>none</code>, <code>sRGB</code>, <code>AdobeRGB</code>, <code>GRAY</code> <code>--quality &lt;1-100&gt;</code> <code>-q</code> JPEG compression quality (1 = highest compression, 100 = best quality) <code>--pagenum &lt;n&gt;</code> <code>-n</code> Page number for multi-page PDF/TIFF input files <code>--region &lt;x,y,w,h&gt;</code> <code>-r</code> Select a region of interest (4 integer values) <code>--reduce &lt;factor&gt;</code> <code>-R</code> Reduce image size by factor (faster than <code>--scale</code>) <code>--size &lt;w,h&gt;</code> <code>-s</code> Resize image to given dimensions <code>--scale &lt;percent&gt;</code> <code>-S</code> Resize image by percentage <code>--mirror &lt;dir&gt;</code> <code>-m</code> Mirror image: <code>none</code>, <code>horizontal</code>, <code>vertical</code> <code>--rotate &lt;angle&gt;</code> <code>-o</code> Rotate image by degrees (0.0 - 360.0) <code>--skipmeta</code> <code>-k</code> Strip all metadata from the output file <code>--topleft</code> Enforce TOPLEFT orientation <code>--watermark &lt;file&gt;</code> <code>-w</code> Overlay a watermark (single-channel grayscale TIFF) <code>--Ctiff_pyramid</code> Store output in pyramidal TIFF format"},{"location":"guide/running/#query-and-compare","title":"Query and Compare","text":"Flag Short Description <code>--query</code> <code>-x</code> Dump all information about the given file <code>--compare &lt;f1&gt; &lt;f2&gt;</code> <code>-C</code> Compare two files pixel-wise"},{"location":"guide/running/#jpeg2000-options","title":"JPEG2000 Options","text":"Flag Description <code>--Sprofile &lt;val&gt;</code> J2K profile: <code>PROFILE0</code>, <code>PROFILE1</code>, <code>PROFILE2</code>, <code>PART2</code>, <code>CINEMA2K</code>, <code>CINEMA4K</code>, <code>BROADCAST</code>, <code>CINEMA2S</code>, <code>CINEMA4S</code>, <code>CINEMASS</code>, <code>IMF</code> <code>--rates &lt;string&gt;</code> Bit-rate(s) for quality layers (<code>-1</code> for lossless final layer) <code>--Clayers &lt;n&gt;</code> Number of quality layers (default: 8) <code>--Clevels &lt;n&gt;</code> Number of wavelet decomposition levels (default: 8) <code>--Corder &lt;val&gt;</code> Progression order: <code>LRCP</code>, <code>RLCP</code>, <code>RPCL</code>, <code>PCRL</code>, <code>CPRL</code> (default: <code>RPCL</code>) <code>--Stiles &lt;string&gt;</code> Tile dimensions <code>\"{tx,ty}\"</code> (default: <code>\"{256,256}\"</code>) <code>--Cprecincts &lt;string&gt;</code> Precinct dimensions <code>\"{px,py}\"</code> (default: <code>\"{256,256}\"</code>) <code>--Cblk &lt;string&gt;</code> Code-block dimensions <code>\"{dx,dy}\"</code> (default: <code>\"{64,64}\"</code>) <code>--Cuse_sop &lt;val&gt;</code> Include SOP markers (default: yes)"},{"location":"guide/running/#server-options","title":"Server Options","text":"Flag Short Env Var Default Description <code>--config &lt;file&gt;</code> <code>-c</code> <code>SIPI_CONFIGFILE</code> Lua configuration file for server mode <code>--serverport &lt;n&gt;</code> <code>SIPI_SERVERPORT</code> <code>80</code> HTTP port <code>--sslport &lt;n&gt;</code> <code>SIPI_SSLPORT</code> <code>443</code> HTTPS port <code>--hostname &lt;name&gt;</code> <code>SIPI_HOSTNAME</code> <code>localhost</code> Public DNS hostname <code>--keepalive &lt;sec&gt;</code> <code>SIPI_KEEPALIVE</code> <code>5</code> HTTP keep-alive timeout in seconds <code>--nthreads &lt;n&gt;</code> <code>-t</code> <code>SIPI_NTHREADS</code> CPU cores Number of worker threads <code>--maxpost &lt;size&gt;</code> <code>SIPI_MAXPOSTSIZE</code> <code>300M</code> Maximum POST upload size <code>--imgroot &lt;path&gt;</code> <code>SIPI_IMGROOT</code> <code>./images</code> Image repository root directory <code>--docroot &lt;path&gt;</code> <code>SIPI_DOCROOT</code> <code>./server</code> Web server document root <code>--wwwroute &lt;path&gt;</code> <code>SIPI_WWWROUTE</code> <code>/server</code> URL route for web server <code>--scriptdir &lt;path&gt;</code> <code>SIPI_SCRIPTDIR</code> <code>./scripts</code> Directory for Lua route scripts <code>--tmpdir &lt;path&gt;</code> <code>SIPI_TMPDIR</code> <code>./tmp</code> Temporary files directory <code>--maxtmpage &lt;sec&gt;</code> <code>SIPI_MAXTMPAGE</code> <code>86400</code> Max age of temp files in seconds <code>--initscript &lt;path&gt;</code> <code>SIPI_INITSCRIPT</code> <code>./config/sipi.init.lua</code> Path to Lua init script <code>--cachedir &lt;path&gt;</code> <code>SIPI_CACHEDIR</code> <code>./cache</code> Cache directory <code>--cachesize &lt;size&gt;</code> <code>SIPI_CACHESIZE</code> <code>200M</code> Maximum cache size <code>--cachenfiles &lt;n&gt;</code> <code>SIPI_CACHENFILES</code> <code>200</code> Maximum number of cached files <code>--cachehysteresis &lt;f&gt;</code> <code>SIPI_CACHEHYSTERESIS</code> <code>0.15</code> Cache purge ratio (0.0 - 1.0) <code>--thumbsize &lt;size&gt;</code> <code>SIPI_THUMBSIZE</code> <code>!128,128</code> Default thumbnail size (IIIF syntax) <code>--sslcert &lt;path&gt;</code> <code>SIPI_SSLCERTIFICATE</code> <code>./certificate/certificate.pem</code> SSL certificate path <code>--sslkey &lt;path&gt;</code> <code>SIPI_SSLKEY</code> <code>./certificate/key.pem</code> SSL key file path <code>--jwtkey &lt;string&gt;</code> <code>SIPI_JWTKEY</code> JWT shared secret (42 chars) <code>--loglevel &lt;level&gt;</code> <code>SIPI_LOGLEVEL</code> <code>DEBUG</code> Log level (see Logging section)"},{"location":"guide/running/#sentry-error-reporting","title":"Sentry Error Reporting","text":"Flag Env Var Description <code>--sentry-dsn &lt;url&gt;</code> <code>SIPI_SENTRY_DSN</code> Sentry DSN for error reporting <code>--sentry-release &lt;ver&gt;</code> <code>SIPI_SENTRY_RELEASE</code> Sentry release version <code>--sentry-environment &lt;env&gt;</code> <code>SIPI_SENTRY_ENVIRONMENT</code> Sentry environment name"},{"location":"guide/running/#deprecated-options","title":"Deprecated Options","text":"Flag Description <code>--salsah</code> Legacy flag for old SALSAH system conversions <code>--subdirlevels &lt;n&gt;</code> Number of subdirectory levels (deprecated) <code>--subdirexcludes &lt;dirs&gt;</code> Directories excluded from subdir calculations <code>--pathprefix</code> Treat IIIF prefix as file path (deprecated)"},{"location":"guide/running/#environment-variables","title":"Environment Variables","text":"<p>All server options can be configured via environment variables. Environment variables override Lua configuration file values but are themselves overridden by command-line flags.</p> Variable CLI Flag Default Description <code>SIPI_CONFIGFILE</code> <code>--config</code> Configuration file path <code>SIPI_SERVERPORT</code> <code>--serverport</code> <code>80</code> HTTP port <code>SIPI_SSLPORT</code> <code>--sslport</code> <code>443</code> HTTPS port <code>SIPI_HOSTNAME</code> <code>--hostname</code> <code>localhost</code> Public hostname <code>SIPI_KEEPALIVE</code> <code>--keepalive</code> <code>5</code> Keep-alive timeout (seconds) <code>SIPI_NTHREADS</code> <code>--nthreads</code> CPU cores Worker threads <code>SIPI_MAXPOSTSIZE</code> <code>--maxpost</code> <code>300M</code> Max POST size <code>SIPI_IMGROOT</code> <code>--imgroot</code> <code>./images</code> Image root directory <code>SIPI_DOCROOT</code> <code>--docroot</code> <code>./server</code> Document root <code>SIPI_WWWROUTE</code> <code>--wwwroute</code> <code>/server</code> Web server route <code>SIPI_SCRIPTDIR</code> <code>--scriptdir</code> <code>./scripts</code> Lua scripts directory <code>SIPI_TMPDIR</code> <code>--tmpdir</code> <code>./tmp</code> Temporary directory <code>SIPI_MAXTMPAGE</code> <code>--maxtmpage</code> <code>86400</code> Max temp file age <code>SIPI_INITSCRIPT</code> <code>--initscript</code> <code>./config/sipi.init.lua</code> Init script path <code>SIPI_CACHEDIR</code> <code>--cachedir</code> <code>./cache</code> Cache directory <code>SIPI_CACHESIZE</code> <code>--cachesize</code> <code>200M</code> Max cache size <code>SIPI_CACHENFILES</code> <code>--cachenfiles</code> <code>200</code> Max cached files <code>SIPI_CACHEHYSTERESIS</code> <code>--cachehysteresis</code> <code>0.15</code> Cache purge ratio <code>SIPI_THUMBSIZE</code> <code>--thumbsize</code> <code>!128,128</code> Thumbnail size <code>SIPI_SSLCERTIFICATE</code> <code>--sslcert</code> <code>./certificate/certificate.pem</code> SSL certificate <code>SIPI_SSLKEY</code> <code>--sslkey</code> <code>./certificate/key.pem</code> SSL key <code>SIPI_JWTKEY</code> <code>--jwtkey</code> JWT secret <code>SIPI_JPEGQUALITY</code> <code>--quality</code> <code>60</code> JPEG quality <code>SIPI_LOGLEVEL</code> <code>--loglevel</code> <code>DEBUG</code> Log level <code>SIPI_SENTRY_DSN</code> <code>--sentry-dsn</code> Sentry DSN <code>SIPI_SENTRY_RELEASE</code> <code>--sentry-release</code> Sentry release <code>SIPI_SENTRY_ENVIRONMENT</code> <code>--sentry-environment</code> Sentry environment <p>Configuration precedence (highest to lowest):</p> <ol> <li>Command-line flags</li> <li>Environment variables</li> <li>Lua configuration file</li> </ol>"},{"location":"guide/running/#exit-codes-and-error-handling","title":"Exit Codes and Error Handling","text":""},{"location":"guide/running/#exit-codes","title":"Exit Codes","text":"<p>When running SIPI as a command-line image converter, the process exit code indicates whether the conversion succeeded:</p> <ul> <li>0 \u2014 Success. The output file was written correctly.</li> <li>1 (<code>EXIT_FAILURE</code>) \u2014 Image processing error. The image could not be read,   converted, or written.</li> </ul> <p>Important for calling services: Always check the exit code. A non-zero exit code means the output file was not produced (or is incomplete).</p>"},{"location":"guide/running/#error-output","title":"Error Output","text":"<p>On failure, SIPI prints a short error message to stderr indicating the failure phase and the specific error. The format is:</p> <pre><code>Error &lt;phase&gt; image: &lt;details&gt;\n</code></pre> <p>Where <code>&lt;phase&gt;</code> is one of <code>reading</code>, <code>converting</code>, or <code>writing</code>. Example:</p> <pre><code>Error reading image: Unsupported JPEG colorspace YCCK (file=input.jpg, dimensions=2048x1536, components=4)\n</code></pre>"},{"location":"guide/running/#sentry-integration-cli-mode","title":"Sentry Integration (CLI Mode)","text":"<p>When the <code>SIPI_SENTRY_DSN</code> environment variable is set, CLI conversion failures automatically send a Sentry event with rich image context. This allows developers to diagnose failures without reproducing them locally.</p> <p>Each Sentry event includes:</p> <ul> <li> <p>Tags (indexed, searchable, filterable in Sentry):</p> <ul> <li><code>sipi.mode</code> \u2014 always <code>cli</code> for command-line conversions</li> <li><code>sipi.phase</code> \u2014 <code>read</code>, <code>convert</code>, or <code>write</code></li> <li><code>sipi.output_format</code> \u2014 the target format (e.g., <code>jpx</code>, <code>jpg</code>, <code>tif</code>, <code>png</code>)</li> <li><code>sipi.colorspace</code> \u2014 the image's photometric interpretation</li> <li><code>sipi.bps</code> \u2014 bits per sample</li> </ul> </li> <li> <p>Context (\"Image\" context with structured data):</p> <ul> <li><code>input_file</code>, <code>output_file</code> \u2014 file paths</li> <li><code>width</code>, <code>height</code> \u2014 image dimensions (if read successfully)</li> <li><code>channels</code> \u2014 number of color channels</li> <li><code>bps</code> \u2014 bits per sample</li> <li><code>colorspace</code> \u2014 photometric interpretation</li> <li><code>icc_profile_type</code> \u2014 ICC profile type (e.g., sRGB, AdobeRGB, CMYK)</li> <li><code>orientation</code> \u2014 EXIF orientation</li> <li><code>file_size_bytes</code> \u2014 input file size</li> </ul> </li> </ul>"},{"location":"guide/running/#common-failure-causes","title":"Common Failure Causes","text":"Error Meaning Unsupported colorspace (YCCK, unknown) The JPEG uses a colorspace SIPI cannot convert. Re-encode the source image in sRGB. Unsupported bits/sample Only 8 and 16 bits/sample are supported. Images with other bit depths must be converted first. Channel/colorspace mismatch The number of channels does not match the declared colorspace (e.g., 4 channels but RGB). The file metadata may be corrupt. ICC profile incompatible The ICC profile does not match the channel count (e.g., CMYK profile on a 3-channel image). Corrupt or truncated file The input file is incomplete or damaged. Unsupported TIFF tiling The TIFF tile configuration is inconsistent or uses unsupported bit depths."},{"location":"guide/running/#integration-notes-for-calling-services","title":"Integration Notes for Calling Services","text":"<p>If you call SIPI CLI from another service (e.g., a Java service):</p> <ol> <li>Check the exit code. Non-zero means failure \u2014 do not assume the output file    exists or is valid.</li> <li>Parse stderr (optional). The first line of stderr contains a human-readable    error message with the failure phase and details.</li> <li>Set <code>SIPI_SENTRY_DSN</code> to get full diagnostics server-side. Use the Sentry    tags <code>sipi.phase</code>, <code>sipi.colorspace</code>, <code>sipi.bps</code>, and <code>sipi.output_format</code> to    build alerts and filters for specific failure patterns.</li> </ol>"},{"location":"guide/running/#configuration-files","title":"Configuration Files","text":"<p>SIPI's configuration file is written in Lua. You can make your own configuration file by adapting <code>config/sipi.config.lua</code>.</p> <ul> <li>Check that the port number is correct and that your operating   system's firewall does not block it.</li> <li>Set <code>imgroot</code> to the directory containing the files to be served.</li> <li>Create the directory <code>cache</code> in the top-level directory of the   source tree.</li> </ul> <p>For more information, see the comments in <code>config/sipi.config.lua</code> and the Reference page for all configuration parameters.</p>"},{"location":"guide/running/#https-support","title":"HTTPS Support","text":"<p>SIPI supports SSL/TLS encryption if the OpenSSL library is installed. You will need to install a certificate; see <code>config/sipi.config.lua</code> for instructions.</p>"},{"location":"guide/running/#iiif-prefixes","title":"IIIF Prefixes","text":"<p>SIPI supports IIIF Image API URLs.</p> <p>If the configuration property <code>prefix_as_path</code> is set to <code>true</code>, the IIIF <code>prefix</code> portion of the URL is interpreted as a subdirectory of <code>imgroot</code>, and SIPI looks for the requested image file in that subdirectory. Otherwise, it looks for the file in <code>imgroot</code>.</p>"},{"location":"guide/sipi/","title":"Basic Information and Reference","text":"<p>This section provides the basic information to use SIPI as a high performance, versatile media server implementing the IIIF standards that can be used in many different settings, from a small standalone server providing basic metadata to the deployment in a complex environment. For more information about the IIIF standard see https://iiif.io. The basic idea is that an image or rectangular region of an image can be downloaded (e.g. to the browser) with a given width and height, rotation, image quality and format. All parameters are provided with the IIIF conformant URL that has the following form:</p> <p><code>http(s)://{server}/{prefix}/{identifier}/{region}/{size}/{rotation}/{quality}.{format}</code></p> <p>The parts do have the following meaning:</p> <ul> <li><code>{server}</code>: The DNS name of the server, eg. <code>iiif.dasch.swiss</code>. The server may include a portnumber,   eg. <code>iiif2.dasch.swiss:8080</code>.</li> <li><code>{prefix}</code>: A path (that may include <code>/</code>'s) to organize the assets. Usually the prefix reflect the internal   directory or folder hierarchy. However this can be overridden using special features of SIPI (see pre-flight-script   and sipi configuration file).</li> <li><code>{identifier}</code>: The identifier of the requested image. By default, it is the filename and its extension.</li> <li><code>{region}</code>: a region of interest that should be displayed. <code>full</code> indicates that the whole image is being requested.   For more details see IIIF regions</li> <li><code>{size}</code>: The size of the displayed image (part). <code>max</code> indicates the the \"natural\" maximal resolution should be used.   For more details see IIIF size</li> <li><code>{rotations}</code>: The image can be rotated and mirrored before being transmitted to the client. SIPI allows for   arbitrary rotations. The Value <code>0</code> indicates no rotation. For more details see   IIIF rotation</li> <li><code>{quality}</code>: The quality parameter determines whether the image is delivered in color, grayscale or black and white.   Valid values are:</li> <li><code>default</code>: the \"natural\" quality of the original image</li> <li><code>color</code>: A color representation</li> <li><code>gray</code>: A gray value representation</li> <li><code>bitonal</code>: A bitonal representation</li> </ul> <p>All quality values are supported by SIPI - <code>{format}</code>: The file format that should be delivered. SIPI supports the following formats, irrelevant on the format   the image as in the repository of SIPI:   - <code>jpg</code>: The image is delivered as JPEG image. Unfortunately the IIIF standard does not allow the dynamic selection      of the compression ratio used in creating the JPEG. However, a server wide rate may be set in the configuration      file.   - <code>tif</code>: The image is delivered as TIFF image.   - <code>png</code>: The image is delivered as PNG image.   - <code>jpx</code>: The image is delivered as JPEG2000 image.   - <code>webp</code>: The image is delivered as WebP image.   - <code>gif</code>: The image is delivered as GIF image.</p> <p>NOTE: PDF's are not supported as an output format. PDF is considered a document format and not an image format.</p>"},{"location":"guide/sipi/#the-sipi-executable","title":"The SIPI Executable","text":"<p>The SIPI executable is a statically linked program that can be started as - command line tool to perform image operations, mainly format conversions - as server deamon that provides IIIF conforming media server</p>"},{"location":"guide/sipi/#using-sipi-as-command-line-tool","title":"Using SIPI as Command Line Tool","text":"<p>The SIPI command line mode can be used for the following tasks:</p>"},{"location":"guide/sipi/#format-conversions","title":"Format Conversions:","text":"<pre><code>/path/to/sipi infile outfile [options]\n</code></pre>"},{"location":"guide/sipi/#print-information-about-file-and-metadata","title":"Print Information about File and Metadata:","text":"<pre><code>/path/to/sipi -x infile\n/path/to/sipi --query infile\n</code></pre>"},{"location":"guide/sipi/#compare-two-images-pixelwise","title":"Compare two Images pixelwise","text":"<p>The images may have different formats: if the have exactely the same pixels, they are considered identical). Metadata is ignored for comparison:</p> <pre><code>/path/to/sipi -C file1 file2\n/path/to/sipi --compare file1 file2\n</code></pre>"},{"location":"guide/sipi/#general-options-for-the-command-line-use","title":"General Options for the Command Line Use","text":"<p>In command line mode, SIPI supports the following options:</p> <ul> <li><code>-h</code>, <code>--help</code>: Display a short help with all options available</li> <li><code>-F &lt;fmt&gt;</code>, <code>--format &lt;fmt&gt;</code>: The format of the output file. Valid are <code>jpx</code>, <code>jp2</code>, <code>jpg</code>, <code>png</code>, <code>tif</code>, <code>webp</code>, and <code>gif</code>.</li> <li><code>-I &lt;profile&gt;</code>, <code>--icc &lt;profile&gt;</code>: Convert the outfile to the given ICC color profile. Supported profiles are <code>sRGB</code>,   <code>AdobeRGB</code> and <code>GRAY</code>.</li> <li><code>-q &lt;num&gt;</code>, <code>--quality &lt;num&gt;</code>: Only used for the JPEG format. Ignored for all other formats. Its a number between 1 and   100, where 1 is equivalent to the highest compression ratio and lowest quality, 100 to the lowest compression ration   and highest quality of the output image.</li> <li><code>-n &lt;num&gt;</code>, <code>--pagenum &lt;num&gt;</code>: Only for input files in multi-page PDF format: sets the page that should be converted.   Ignored for all other input file formats.</li> <li><code>-r &lt;x&gt; &lt;y&gt; &lt;nx&gt; &lt;ny&gt;</code>, <code>--region &lt;x&gt; &lt;y&gt; &lt;nx&gt; &lt;ny&gt;</code>: Selects a region of interest that should be converted. Needs   4 integer values: <code>left_upper_corner_X</code>, <code>left_upper_corner_Y</code>, <code>width</code>, <code>height</code>.</li> <li><code>-s &lt;iiif-size&gt;</code>, <code>--size &lt;iif-size&gt;</code>: The size of the resulting image. The option requires a string parameter   formatted according to the size-syntax of IIIF see IIIF-Size. Not giving   this parameters results in having the maximalsize (as the value <code>\"max\"</code>would give).</li> <li><code>-s &lt;num&gt;</code>, <code>--scale &lt;num&gt;</code>: Scaling the image size by the given number (interpreted as percentage). Percentage must   be given as integer value. It may be bigger than 100 to upscale an image.</li> <li><code>-R &lt;num&gt;</code>, <code>--reduce &lt;num&gt;</code>: Reduce the size of the image by the given factor. Thus <code>-R 2</code>would resize the image to   half of the original size. Using <code>--reduce</code> is usually much faster than using <code>--scale</code>, e.g. <code>--reduce 2</code> is faster   than <code>--scale 50</code>.</li> <li><code>-m &lt;val&gt;</code>, <code>--mirror &lt;val&gt;</code>: Takes either <code>horizontal</code> or <code>vertical</code>as parameter to mirror the image appropriately.</li> <li><code>-o &lt;angle&gt;</code>, <code>--rotate &lt;angle&gt;</code>: Rotates the image by the given angle. The angle must be a floating point (or   integer) value between <code>0.0</code>and <code>w60.0</code>.</li> <li><code>-k</code>, <code>--skipmeta</code>: Strip all metadata from inputfile.</li> <li><code>-w &lt;filepath&gt;</code>, <code>--watermark &lt;filepath&gt;</code>: Overlays a watermark to the output image.  must be a single   channel, gray valued TIFF. That is, the TIFF file must have the following tag values: SAMPLESPERPIXEL = 1,   BITSPERSAMPLE = 8, PHOTOMETRIC = PHOTOMETRIC_MINISBLACK."},{"location":"guide/sipi/#jpeg2000-specific-options","title":"JPEG2000 Specific Options","text":"<p>Usually, the SIPI command line tool is used to create JPEG2000 images suitable for a IIIF repository. SIPI supports the following JPEG2000 specific options. For a in detail description of these options consult the kakadu documentation!</p> <ul> <li><code>--Sprofile &lt;profile&gt;</code>: The following JPEG2000 profiles are supported: <code>PROFILE0</code>, <code>PROFILE1</code>, <code>PROFILE2</code>, <code>PART2</code>,   <code>CINEMA2K</code>, <code>CINEMA4K</code>, <code>BROADCAST</code>, <code>CINEMA2S</code>, <code>CINEMA4S</code>, <code>CINEMASS</code>, <code>IMF</code>. Default: <code>PART2</code>.</li> <li><code>--rates &lt;string&gt;</code>: One or more bit-rates (see kdu_compress help!). A value \"-1\" may be used in place of the first   bit-rate in the list to indicate that the final quality layer should include all compressed bits.</li> <li><code>--Clayers &lt;num&gt;</code>:Number of quality layers. Default: 8.</li> <li><code>--Clevels &lt;num&gt;</code>: Number of wavelet decomposition levels, or stages. Default: 8.</li> <li><code>--Corder &lt;val&gt;</code>: Progression order. The four character identifiers have the following interpretation:   L=layer; R=resolution; C=component; P=position. The first character in the identifier refers to the index which   progresses most slowly, while the last refers to the index which progresses most quickly.   Thus must be one of <code>LRCP</code>, <code>RLCP</code>, <code>RPCL</code>, <code>PCRL</code>, <code>CPRL</code>, Default: <code>RPCL</code>.</li> <li><code>--Stiles &lt;string&gt;</code>: Tiles dimensions <code>\"{tx,ty}\"</code>. Default: <code>\"{256,256}\"</code>.</li> <li><code>--Cprecincts &lt;string&gt;</code>: Precinct dimensions <code>\"{px,py}\"</code> (must be powers of 2). Default: <code>\"{256,256}\"</code>.</li> <li><code>--Cblk &lt;string&gt;</code>: Nominal code-block dimensions <code>\"{dx,dy}\"</code>(must be powers of 2, no less than 4 and no greater than 1024,   whose product may not exceed 4096). Default: <code>\"{64,64}\"</code>.</li> <li><code>--Cuse_sop &lt;val&gt;</code>: Include SOP markers (i.e., resync markers). Default: yes.</li> </ul>"},{"location":"guide/sipi/#using-sipi-as-iiif-media-server","title":"Using SIPI as IIIF Media Server","text":"<p>In order to use SIPI as IIIF media server, some setup work has to be done. The configuration of SIPI can be done using a configuration file (that is written in LUA) and/or using environment variables, and/or command line options.</p> <p>The priority is as follows: <code>configuration file parameters</code> are overwritten by <code>environment variables</code> are overwritten by <code>command line options</code>.</p> <p>The SIPI server requires a few directories to be setup and listed in the configuration file. Then the SIPI server is launched as follows:</p> <pre><code>/path/to/sipi --config /path/to/config-file.lua\n</code></pre>"},{"location":"guide/sipi/#sipi-specific-extensions-to-iiif","title":"SIPI specific extensions to IIIF","text":"<p>SIPI implements some backwards compatible, non-standard extensions to the IIIF Image API:</p>"},{"location":"guide/sipi/#access-to-a-raw-files","title":"Access to a raw files","text":"<p>Sometimes it may be usefull to store non-image files such as XML-sidecars, manifests as JSON or complete PDF's, etc. in the same environment as the images. For this reason SIPI supports an extension of the IIIF API:</p> <pre><code>http(s)://{server}/{prefix}/{identifier}/file\n</code></pre> <p>The <code>/file</code>-path at the end of the URL makes SIPI to send the file as it is. Thus, for example a manifest file could be accessed by</p> <pre><code>https://iiif.my.server/images/myimage.json/file\n</code></pre> <p>This works also for PDF's. The URL</p> <pre><code>https://iiif.my.server/images/mydocument.pdf/file\n</code></pre> <p>will download the PDF in toto to be opened by an external viewer or the webapplication.</p> <p>It is possible to use the IIIF-<code>info.json</code> syntax also on non-image files. In this case the <code>info.json</code> has the following format:</p> <pre><code>{\n   \"@context\": \"http://sipi.io/api/file/3/context.json\",\n   \"id\": \"http://localhost:1024/images/test.csv\",\n   \"mimeType\": \"text/comma-separated-values\",\n   \"fileSize\": 327\n}\n</code></pre>"},{"location":"guide/sipi/#setup-of-sipi-directories","title":"Setup of SIPI Directories","text":"<p>SIPI needs the following directories and files setup and accessible (the real names of the directories must be indicated in the configuration file). The following configuration parameters are in the <code>sipi</code>-table of the configuration script:</p> <ul> <li> <p><code>imgroot=path</code>: This is the top-directory of the media file repository. SIPI should at least have read access to it. If   SIPI is used to upload and convert files, it must also have write access. The path may be given as absolute path or   as relative path. Cmdline option: <code>--imgroot</code> Environment variable: <code>SIPI_IMGROOT</code> Default: <code>./images</code></p> </li> <li> <p><code>initscript=path/to/init.lua</code>: SIPI needs a minmal set of LUA functions that can be adapted to the local installation.   These mandatory functions are definied in a init-script (usually it can be found in the config directory where also   the configuration file is located). Cmdline option: <code>--initscript</code> Environment variable: <code>SIPI_INITSCRIPT</code> Default: <code>./config/sipi.init.lua</code></p> </li> <li> <p><code>tmpdir=path</code>: For the support of multipart POST SIPI requires read/write access to a directory to save temporary   files. Cmdline option: <code>--tmpdir</code> Environment variable: <code>SIPI_IMGROOT</code> Default: <code>./tmp</code></p> </li> <li> <p><code>scriptdir=path</code>: Path to the directory where the LUA-scripts for the routes (e.g. RESTful services) can be found. Cmdline option: <code>--scriptdir</code> Environment variable: <code>SIPI_SCRIPTDIR</code> Default: <code>./scripts</code></p> </li> <li> <p><code>cachedir=path</code>: SIPI may optionally use a cache directory to store converted image in order to avoid computationally   intensive conversions if a specific variant is requested several times. Sipi starts with a warning if the cache   directory is defined but not existing. Cmdline option: <code>--cachedir</code> Environment variable: <code>SIPI_CACHEDIR</code> Default: <code>./cache</code></p> </li> </ul> <p>In addition, SIPI can act as a webserver that offers image upload and conversion as web service. In order to use this feature, a server directory has to be defined. This definition ist in the <code>fileserver</code>-table of the configuration file:</p> <ul> <li><code>docroot=path</code>: Path to the document root of the SIPI web server. Cmdline option: <code>--docroot</code> Environment variable: <code>SIPI_DOCROOT</code> Default: <code>./server</code></li> </ul>"},{"location":"guide/sipi/#sipi-configuration-parameters","title":"SIPI Configuration Parameters","text":"<p>The following configuration parameters are used by the SIPI server:</p> <ul> <li> <p><code>hostname=dns-name</code>: The DNS name that SIPI shall show to the outside world. It should be   the dns name the client uses to access the SIPI server (and not internal hostnames by proxies etc.).    Cmdline option: <code>--hostname</code> Environment variable: <code>SIPI_HOSTNAME</code> Default: <code>localhost</code></p> </li> <li> <p><code>port=portnum</code>: Portnumber SIPI should listen on for incoming HTTP requests. Cmdline option: <code>--serverport</code> Environment variable: <code>SIPI_SERVERPORT</code> Default: <code>80</code></p> </li> <li> <p><code>ssl_port=portnum</code>: Portnumber SIPI should listen on for incoming SHTTP requests (using SSL). Cmdline option: <code>--sslport</code> Environment variable: <code>SIPI_SSLPORT</code> Default: <code>443</code></p> </li> <li> <p><code>nthreads=num</code>: Number of worker threads that SIPI allocates. SIPI is a mutlithreaded server and pre-allocates a   given number of working threads that can be configured. Cmdline option: <code>--nthreads</code> Environment variable: <code>SIPI_NTHREADS</code> Default: number of hardware cores as given by <code>std::thread::hardware_concurrency()</code></p> </li> <li> <p><code>prefix_as_path=bool</code>: If <code>true</code>, the prefix is used as path within the image root directory. If false, the prefix   is ignored and it is assumed that all images are directly located in the image root. Cmdline option: <code>--pathprefix</code> Environment variable: <code>SIPI_PATHPREFIX</code> Default: <code>false</code></p> </li> <li> <p><code>ssl_certificate=path</code>: Path to the SSL certificate. Is mandatory if SSL is to be used. Cmdline option: <code>--sslcert</code> Environment variable: <code>SIPI_SSLCERTIFICATE</code> Default: <code>./certificate/certificate.pem</code></p> </li> <li> <p><code>ssl_key=path</code>: Path to the SSL key file. Is mandatory if SSL is to be used. Cmdline option: <code>--sslkey</code> Environment variable: <code>SIPI_SSLKEY</code> Default: <code>./certificate/key.pem</code> <li> <p><code>jwt_secret=string</code>: Shared secret to encode web tokens. Cmdline option: <code>--jwtkey</code> Environment variable: <code>SIPI_JWTKEY</code> Default: <code>UP 4888, nice 4-8-4 steam engine</code></p> </li> <li> <p><code>max_post_size=amount</code>: Maximal size a file upload may have. The amount has the   form \"\" where <code>number</code> is an integer value and <code>type</code>an \"M\" for Megabytes, \"G\" for Gigabytes   and \"\" (empty) for bytes. Cmdline option: <code>--maxpost</code> Environment variable: <code>SIPI_MAXPOSTSIZE</code> Default: <code>300M</code> <li> <p><code>keep_alive</code> : Number of seconds a connection (socket) remains open at maximum (\"keep-alive\"),   if a client requests a \"keep-alive\" connection in the request header. For more information see   Keep-Alive. Cmdline option: <code>--keepalive</code> Environment variable: <code>SIPI_KEEPALIVE</code> Default: <code>5</code></p> </li> <li> <p><code>jpeg_quality=num</code>: Compression parameter when producing JPEG output. Must be a number   between 1 and 100. Unfortunately, the IIIF Image API does not allow to give a JPEG quality (=compression) on the IIIF URL. SIPI   allows to configure the compression quality system wide with this parameter. Allowed values are in he range   [1..100] where 1 the worst quality (and highest compression factor = smallest file size) and 100 the highest   quality (with the lowest compression factor = biggest file size). Please note that SIPI is not able to provide   lossless compression for JPEG files. Cmdline option: <code>--quality</code> Environment variable: <code>SIPI_JPEGQUALITY</code> Default: <code>60</code> <li> <p><code>thumb_size=string</code>: Default size for thumbnails. Parameter must be IIIF conformant size string. This configuration   parameter can be used to define a default value for creating thumbnails. It has no direct implications but can be   used in LUA scripts (e.g. the pre_flight-function). Cmdline option: <code>--thumbsize</code> Environment variable: <code>SIPI_THUMBSIZE</code> Default: <code>!128,128</code></p> </li> <li> <p><code>logfile=path</code>: SIPI uses syslog as logging facility. The logging name   is <code>Sipi</code>. It supports the following levels:   \"EMERGENCY\", \"ALERT\", \"CRITICAL\", \"ERROR\", \"WARNING\", \"NOTICE\", \"INFORMATIONAL\", \"DEBUG\". Cmdline option: <code>--logfile</code> Environment variable: <code>SIPI_LOGFILE</code> Default: <code>Sipi</code></p> </li> <li> <p><code>loglevel=level</code>: SIPI uses syslog as logging facility. The logging name is <code>Sipi</code>. It supports the following levels:   \"EMERGENCY\", \"ALERT\", \"CRITICAL\", \"ERROR\", \"WARNING\", \"NOTICE\", \"INFORMATIONAL\", \"DEBUG\". Cmdline option: <code>--loglevel</code> Environment variable: <code>SIPI_LOGLEVEL</code> Default: <code>DEBUG</code></p> </li> <li> <p><code>max_temp_file_age=num</code>: The maximum allowed age of temporary files (in seconds) before they are deleted. Cmdline option: <code>--maxtmpage</code> Environment variable: <code>SIPI_MAXTMPAGE</code> Default: <code>86400</code> (one day)</p> </li>"},{"location":"guide/sipi/#cache-configuration","title":"Cache Configuration","text":"<p>SIPI may optionally use a cache directory to store converted image in order to avoid computationally intensive conversions if a specific variant is requested several times. The cache is based on timestamps and the canonical IIIF URL. Before an image is being converted, the canonical URL is determined. If a file associated with this canonical URL is in the cache directory, the timestamp of the original file in the repository is compated to the cached file. If the cached file is newer, it will be served. If the file in the repository is newer, the cache file (which is outdated) will be deleted and replaced be the newly converted repository file (that is being sent to the client).</p> <p>The following configuration parameters determine the behaviour of the cache:</p> <ul> <li> <p><code>cachedir=path</code>: SIPI may optionally use a cache directory to store converted image in order to avoid computationally   intensive conversions if a specific variant is requested several times. Sipi starts with a warning if the cache   directory is defined but not existing. Cmdline option: <code>--cachedir</code> Environment variable: <code>SIPI_CACHEDIR</code> Default: <code>./cache</code></p> </li> <li> <p><code>cachesize=amount</code>: The maximal size of the cache. The cache will be purged if either the maximal size or maximal   number of files is reached. The amount has the form \"M\" with M indication Megabytes. Cmdline option: <code>--cachesize</code> Environment variable: <code>SIPI_CACHESIZE</code> Default: <code>200M</code> <li> <p><code>cache_nfiles=num</code>: The maximal number of files to be cached. The cache will be purged if either the maximal size    or maximal number of files is reached. Cmdline option: <code>--cachenfiles</code> Environment variable: <code>SIPI_CACHENFILES</code> Default: <code>200</code></p> </li> <li> <p><code>cache_hysteresis=float</code>: If the cache becomes full, the given percentage of file space is marked for reuse and purged. Cmdline option: <code>--cachehysteresis</code> Environment variable: <code>SIPI_CACHEHYSTERESIS</code> Default: <code>0.15</code></p> </li>"},{"location":"guide/sipi/#configuration-of-the-http-file-server","title":"Configuration of the HTTP File Server","text":"<p>SIPI offers  HTTP file server for HTML and other files. Files with the ending <code>.elua</code> are HTTP-files with embeded LUA code. Everything between the ... tags is interpreted as LUA code and the output embedded in the data stream for the client.</p> <p>All configurations for the HTTP server are in the <code>fileserver</code> table:</p> <ul> <li> <p><code>docroot=path</code>: Path to the document root of the file server. Cmdline option: <code>--docroot</code> Environment variable: <code>SSIPI_DOCROOT</code> Default: <code>./server</code></p> </li> <li> <p><code>wwwroute=string</code>: Route for the file server should respond to requests.That is, a file with the name \"dada.html\"   is accessed with <code>http://dnsname/server/dada.html</code>, if the <code>wwwroute</code>is set to <code>/server</code>. Cmdline option: <code>--wwwroute</code> Environment variable: <code>SIPI_WWWROUTE</code> Default: <code>/server</code></p> </li> </ul>"},{"location":"guide/sipi/#configuration-of-administrator-access","title":"Configuration of Administrator Access","text":"<p>SIPI allows special administrator access for some tasks. In order to allow for this, an administrator has to be defined as follows: <pre><code>admin = {\n    --\n    -- username of admin user\n    --\n    user = 'admin',\n\n    --\n    -- Administration password\n    --\n    password = 'Sipi-Admin'\n}\n</code></pre> If You're using the administrator user, please make sure that the config file is not exposed!</p>"},{"location":"guide/sipi/#routing-table","title":"Routing Table","text":"<p>SIPI allows to implement RESTful interfaces or other services based on LUA-scripts which are located in the scripts directory. In order to use these LUA-scripts as endpoints, the appropriate routes have to be defined in the <code>routes</code> table. An entry has the following form: - <code>method</code>: the HTTP request. Supported are <code>GET</code>, <code>POST</code>, <code>PUT</code> and <code>DELETE</code>. - <code>route</code>: A URL path that may contain <code>/</code>'s. - <code>script</code>: Name of the LUA script in the script directory.</p> <p>Thus, the routing section of a SIPI configuration file may look as follows:</p> <pre><code>routes = {\n    {\n        method = 'DELETE',\n        route = '/api/cache',\n        script = 'cache.lua'\n    },\n    {\n        method = 'GET',\n        route = '/api/cache',\n        script = 'cache.lua'\n    },\n    {\n        method = 'POST',\n        route = '/api/upload',\n        script = 'upload.lua'\n    },\n    {\n        method = 'GET',\n        route = '/sqlite',\n        script = 'test_sqlite.lua'\n    }\n}\n</code></pre>"},{"location":"lua/","title":"SIPI Lua Interface","text":"<p>SIPI has an embedded LUA interpreter. LUA is a simple script language that was developped specifically to be embedded into applications. For example the games minecraft and World of Warcraft make extensive use of LUA scripting for customization and programming extensions.</p> <p>Each HTTP request to SIPI invokes a recent, independent lua-instance (Version 5.3.5). Therefore, LUA may be used in the following contexts:</p> <ul> <li>Preflight function</li> <li>Embedded in HTML pages</li> <li>RESTful services using the SIPI routing</li> </ul> <p>Each lua-instance in SIPI includes additional SIPI-specific information:</p> <ul> <li>global variables about the SIPI configuration</li> <li>information about the current HTTP request</li> <li>SIPI specific functions for</li> <li>processing the request and send back information</li> <li>getting image information and transforming images</li> <li>querying and changing the SIPI runtime configuration (e.g. the cache)</li> </ul> <p>In general, the SIPI LUA function make use that a Lua function's return value may consist of more than one element (see Multiple Results):</p> <p>Sipi provides the LuaRocks package manager which must be used in the context of SIPI.</p> <p>The Lua interpreter in Sipi runs in a multithreaded environment: each request runs in its own thread and has its own Lua interpreter. Therefore, only Lua packages that are known to be thread-safe may be used!</p>"},{"location":"lua/#preflight-function","title":"Preflight function","text":"<p>It is possible to define a LUA pre-flight function for IIIF-requests and independently one for file-requests (indicated by a /file postfix in the URL). Both are optional and are best located in the init-script (see configuration options of SIPI). It is executed after the incoming HTTP request data has been processed but before an action to respond to the request has been taken. It should be noted that the pre-flight script is only executed for IIIF-specific requests (either using the IIIF URL-syntax or the /file postfix). All other HTTP requests are being directed to \"normal\" HTTP-server part of SIPI. These can utilize the lua functionality by embedding LUA commands within the HTML.</p>"},{"location":"lua/#iiif-preflight-function","title":"IIIF preflight function","text":"<p>The IIIF preflight function must have the name pre_flight with the following signature:</p> <p><pre><code>function pre_flight(prefix,identifier,cookie)\n\n    return \"allow\", filepath\nend\n</code></pre> The preflight function takes 3 parameter:</p> <ul> <li><code>prefix</code>: This is the prefix that is given on the IIIF url [mandatory] http(s)://{server}/{prefix}/{id}/{region}/{size}/{rotation}/{quality}.{format}   Please note that the prefix may contain several \"/\" that can be used as path to the repository file</li> <li><code>identifier</code>: The image identifier (which must not correspond to an actual filename in the media files repositoy   of the SIPI IIIF server)   [mandatory]</li> <li><code>cookie</code>: A cookie containing authorization information. Usually the cookie contains a Json Web Token [optional]</li> </ul> <p>The pre-flight function must return at least 2 parameters:</p> <ul> <li><code>permission</code>: A string or a table indication the permission to read the image. In a simple case it's either the   string <code>\"allow\"</code> or <code>\"deny\"</code>.   To allow more flexibility, the following permission tables are supported:  <ul> <li>Restricted access with watermark. The watermark must be a TIFF file with a single 8-bit channel (gray value image). For example: <code>{ type = 'restrict', watermark = './wm/mywatermark.tif' }</code></li> <li>Restricted access with size limitation. The size must be a   IIIF size expression. For example: <code>{ type = 'restrict', size='!256,256' }</code></li> <li>SIPI also supports the IIIF Authentification API. See section IIIF   Authentification on how to implement this feature in the pre-flight function.</li> </ul> </li> <li><code>filepath</code>: The path to the master image file in the media files repository. This path can be assembled using the   <code>prefix</code> and <code>identifier</code> using any additional information (e.g. accessing a database or using the LUA restful client)</li> </ul> <p>The most simple working pre-flight looks as follows assuming that the <code>identifier</code>is the name of the master image file in the repository and the <code>prefix</code> is the path: <pre><code>function pre_flight(prefix, identifier, cookie)\n    if config.prefix_as_path then\n        filepath = config.imgroot .. '/' .. prefix .. '/' .. identifier\n    else\n        filepath = config.imgroot .. '/' .. identifier\n    end\n    return 'allow', filepath\nend\n</code></pre> Above example preflight function allows all files to be served without restriction.</p>"},{"location":"lua/#more-complex-example-of-preflight-function","title":"More complex example of preflight function","text":"<p>The following example uses some SIPI lua funtions to access an authorization server to check if the user (identified by a cookie) is allowed to see the specific image. We are using Json Web Tokens (JWT) which are supported by SIPI specific LUA functions. Please note that the SIPI JTW-functions support an arbitrary payload that has not to follow the JWT recommendations. In order to encode, the JWT_ALG_HS256 is beeing used together with the key that is defined in the SIPI configuration as jwt_secret. <pre><code>function pre_flight(prefix, identifier, cookie) \n    --\n    -- make up the file path\n    --\n    if config.prefix_as_path then\n        filepath = config.imgroot .. '/' .. prefix .. '/' .. identifier\n    else\n        filepath = config.imgroot .. '/' .. identifier\n    end\n    --\n    -- we need a cookie containing the user information that will be\n    -- sent to the authorization server. In this\n    -- example, the content does not follow the JWT rules\n    -- (which is possible to pack any table into a JWT encoded token)\n    --\n    if cookie then\n        --\n        -- we decode the cookie in order to get a table of key/value pairs\n        --\n        success, userinfo = server.decode_jwt(cookie)\n        if not success then\n            return 'deny', filepath\n        end\n        --\n        -- prepare the RESTful call to the authorization server\n        --\n\n        -- add the image identifier to the info table:\n        userinfo[\"imgid\"] = identifier\n        -- encode the userinfo to a JWT-like token:\n        local new_cookie = server.generate_jwt(userinfo) \n        local url = 'http://auth.institution.org/api/getauth/' .. identifier\n        local auth_information = { Cookie = new_cookie }\n        --\n        -- make the HTTP request with a timeout of 500 ms\n        --\n        success, result = server.http('GET', url, auth_information, 500) \n        if success then\n            --\n            -- we got a response from the server\n            --\n            success, response_json = server.json_to_table(result.body)\n            if success then  -- everything OK\n                return {\n                            type = response_json.type,\n                            restriction = response_json.restriction\n                        }, filepath\n            else\n                return 'deny', filepath\n            end\n        else\n            return 'deny', filepath\n        end\n    else\n        return 'deny', filepath\n    end\nend\n</code></pre> Above example assumes that the cookie data is a string that contains encrypted user data from a table (key/value pair). Jason Web Token. This token is decoded and the information about the image to be displayed is added. Then the information is encoded as a new token that ist transmitted to the RESTful interface of the authentification server. The answer is assumed to be json containing information about the type ('allow', 'deny', 'restrict') and the restriction settings. The pre-flight function uses the following SIPI-specific LUA global variables and function:</p> <ul> <li>config.imgroot: (Global variable) Root directory of the image repository.</li> <li>server.http(): (Function) Used to create a RESTful GET request.</li> <li>server.generate_jwt(): (Function) Create a new JWT token from a key/value table.</li> <li>server.json_to_table(): (function) Convert a JSON into a LUA table.</li> </ul>"},{"location":"lua/#file-preflight-function","title":"File preflight function","text":"<p>An URL in the form <code>http(s)://{server}/{prefix}/{identifier}/file</code> serves the given file as binary object (including propere mimetype in the header etc.). The file has to reside in the directory tree defined for IIIF requests. In these cases, a preflight script name <code>file_pre_flight</code> is being called if defined. Its signature is as follows: <pre><code>function file_pre_flight(filepath, cookie)\n\nend\n</code></pre> A simple example allowing access only to the file \"unit/test.csv\" would be: <pre><code>function file_pre_flight(filepath, cookie)\n    if filepath == \"./images/unit/test.csv\" then\n        return \"allow\", filepath\n    else\n        return \"deny\", \"\"\n    end\nend\n</code></pre> This script would deny all other file access and the SIPI IIIF server responds with a <code>401 Unauthorized</code> error.</p>"},{"location":"lua/#lua-embedded-in-html","title":"LUA embedded in HTML","text":"<p>The HTTP server that is included in SIPI can serve any type of file which are just transfered as is to the client. However, if a file has an extension of <code>.elua</code>, it is assumed to be a HTML file with embedded LUA code. ALL SIPI-specific LUA functions and global variables are available.</p> <p>Embedding works with the special tag <code>&lt;lua&gt;</code> and <code>&lt;/lua&gt;</code>. All text between the opening and closing tag is interpreted as LUA code. SIPI provides an extra LUA function to output data to the client (server.print). Thus, dynamic, server-generated HTML may be created. A sample page that displays some information about the server configuration and client info could like follows: <pre><code>&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;SIPI Configuration Info&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n    &lt;h1&gt;SIPI Configuration Info&lt;/h1&gt;\n    &lt;h2&gt;Configuration variables&lt;/h2&gt;\n    &lt;table&gt;\n        &lt;tr&gt;\n            &lt;td&gt;imgroot&lt;/td&gt;\n            &lt;td&gt;:&lt;/td&gt;\n            &lt;td&gt;&lt;lua&gt;server.print(config.imgroot)&lt;/lua&gt;&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;docroot&lt;/td&gt;\n            &lt;td&gt;:&lt;/td&gt;\n            &lt;td&gt;&lt;lua&gt;server.print(server.docroot)&lt;/lua&gt;&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;hostname&lt;/td&gt;\n            &lt;td&gt;:&lt;/td&gt;\n            &lt;td&gt;&lt;lua&gt;server.print(config.hostname)&lt;/lua&gt;&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;scriptdir&lt;/td&gt;\n            &lt;td&gt;:&lt;/td&gt;\n            &lt;td&gt;&lt;lua&gt;server.print(config.scriptdir)&lt;/lua&gt;&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;cachedir&lt;/td&gt;\n            &lt;td&gt;:&lt;/td&gt;\n            &lt;td&gt;&lt;lua&gt;server.print(config.cache_dir)&lt;/lua&gt;&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;tmpdir&lt;/td&gt;\n            &lt;td&gt;:&lt;/td&gt;\n            &lt;td&gt;&lt;lua&gt;server.print(config.tmpdir)&lt;/lua&gt;&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;port&lt;/td&gt;\n            &lt;td&gt;:&lt;/td&gt;\n            &lt;td&gt;&lt;lua&gt;server.print(config.port)&lt;/lua&gt;&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;lua&gt;\n            if server.has_openssl then\n                server.print('&lt;tr&gt;&lt;td&gt;SSL port&lt;/td&gt;&lt;td&gt;:&lt;/td&gt;&lt;td&gt;' ..\n                             config.sslport .. '&lt;/td&gt;&lt;/tr&gt;')\n            end\n        &lt;/lua&gt;\n        &lt;tr&gt;\n            &lt;td&gt;number of threads:&lt;/td&gt;\n            &lt;td&gt;:&lt;/td&gt;\n            &lt;td&gt;&lt;lua&gt;server.print(config.n_threads)&lt;/lua&gt;&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;maximal post size:&lt;/td&gt;\n            &lt;td&gt;:&lt;/td&gt;\n            &lt;td&gt;&lt;lua&gt;server.print(config.max_post_size)&lt;/lua&gt;&lt;/td&gt;\n        &lt;/tr&gt;\n    &lt;/table&gt;\n    &lt;h2&gt;Client information&lt;/h2&gt;\n    &lt;table&gt;\n        &lt;tr&gt;\n            &lt;td&gt;Host in request&lt;/td&gt;\n            &lt;td&gt;:&lt;/td&gt;\n            &lt;td&gt;&lt;lua&gt;server.print(server.host)&lt;/lua&gt;&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;IP of client&lt;/td&gt;\n            &lt;td&gt;:&lt;/td&gt;\n            &lt;td&gt;&lt;lua&gt;server.print(server.client_ip)&lt;/lua&gt;&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;URL path&lt;/td&gt;\n            &lt;td&gt;:&lt;/td&gt;\n            &lt;td&gt;&lt;lua&gt;server.print(server.uri)&lt;/lua&gt;&lt;/td&gt;\n            &lt;/tr&gt;\n    &lt;/table&gt;\n\n    &lt;p&gt;Important Note: \"IP of client\" and \"Host in request\" may\n       indicate the information of a proxy and notof the actual\n       client!&lt;/p&gt;\n    &lt;h2&gt;Request Header Information&lt;/h2&gt;\n    &lt;table&gt;\n        &lt;lua&gt;\n            for key, val in pairs(server.header) do\n                server.print('&lt;tr&gt;&lt;td&gt;' .. key ..\n                             '&lt;/td&gt;&lt;td&gt;:&lt;/td&gt;&lt;td&gt;' .. val .\n                             '&lt;/td&gt;&lt;/tr&gt;')\n            end\n        &lt;/lua&gt;\n    &lt;/table&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p>"},{"location":"lua/#embedded-lua-and-enforcing-ssl","title":"Embedded LUA and enforcing SSL","text":"<p>The supplied example initialization file offers a LUA function that enforces the use of a SSL encryption page proteced by a user name and password. It is used as follows by adding the following code before the <code>&lt;html&gt;</code> opening tag:</p> <p><pre><code>&lt;lua&gt;\n    if server.secure then\n        protocol = 'https://'\n    else\n        protocol = 'http://'\n    end\n\n    success,token = authorize_page('admin.sipi.org',\n                                   'administrator',\n                                    extecteduser, expectedPassword)\n    if not success then\n        return\n    end\n&lt;/lua&gt;\n</code></pre> where <code>expectedUser</code> and <code>extectedPassword</code> are the user/password combination the user is expected to enter.</p>"},{"location":"lua/#file-uploads-to-sipi","title":"File uploads to SIPI","text":"<p>The SIPI specific LUA function allow the upload of files using POST requests with <code>multipart/form-data</code> content. The global variable <code>server.uploads</code> contains`the information about the uploads. The following variables and function help to deal with uploads:</p> <ul> <li>server.uploads : information about the files in the upload request.</li> <li>server.copyTmpfile : copies a fie from the upload location to the destination directory.</li> </ul> <p>In addition the file system functions that SIPI provides may be used.</p> <p>See the scripts <code>upload.elua</code> and <code>do-upload.elua</code> in the server directory, and <code>upload.lua</code> in the scripts directory for a working example.</p>"},{"location":"lua/#restful-api-and-custom-routes","title":"RESTful API and custom routes","text":"<p>Custom routes to implement a RESTful API can be defined in Sipi's configuration file using the <code>routes</code> configuration variable. For example:</p> <pre><code>routes = {\n    {\n        method = 'GET',\n        route = '/status',\n        script = 'get_repository_status.lua'\n    },\n    {\n        method = 'POST',\n        route = '/make_thumbnail',\n        script = 'make_image_thumbnail.lua'\n    }\n}\n</code></pre> <p>Sipi looks for these scripts in the directory specified by <code>scriptdir</code> in its configuration file. The first route that matches the beginning of the requested URL path will be used.</p>"},{"location":"lua/#iiif-authentication-api-10-in-sipi","title":"IIIF Authentication API 1.0 in SIPI","text":"<p>The <code>pre_flight</code> function is also responsible for activating the IIIF Auth API. In order to do so, the pre_flight script returns a table that contains all necessary information. For details about the IIIF Authentication API 1.0 see the IIIF documentation. The following fields have to be returned by the <code>pre_flight</code>-function as LUA-table:</p> <ul> <li><code>type</code>: String giving the type. Valid are: <code>\"login\"</code>, <code>\"clickthrough\"</code>, <code>\"\"kiosk\"</code> or <code>\"external\"</code>.</li> <li><code>cookieUrl</code>: URL where to get a valid IIIF Auth cookie for this service.</li> <li><code>tokenUrl</code>: URL where to get a valid IIIF Auth token for this service.</li> <li><code>confirmLabel</code>: Label to display in confirmation box.</li> <li><code>description</code>: Description for login window.</li> <li><code>failureDescription</code>: Information, if login fails.</li> <li><code>failureHeader</code>: Header for failure window.</li> <li><code>header</code>: Header of login window</li> <li><code>label</code>: Label of the login window</li> </ul> <p>In addition, the filepath has to be returns. A full response may look as follows:</p> <pre><code>return {\n   type = 'login',\n    cookieUrl = 'https://localhost/iiif-cookie.html',\n    tokenUrl = 'https://localhost/iiif-token.php',\n    confirmLabel =  'Login to SIPI',\n    description = 'This Example requires a demo login!',\n    failureDescription = '&lt;a href=\"http://example.org/policy\"&gt;Access Policy&lt;/a&gt;',\n    failureHeader = 'Authentication Failed',\n    header = 'Please Log In',\n    label = 'Login to SIPI',\n}, filepath\n</code></pre> <p>SIPI will use this information returned by the <code>pre_flight</code> function to return the appropriate responses to the client requests based on the IIIF Authentication API 1.0. Check for support of the IIIF Authentication API 1.0 for mirador and universalviewer, both applications which suppport the IIIF standards.</p>"},{"location":"lua/#sipi-variables-available-to-lua-scripts","title":"SIPI variables available to Lua scripts","text":"<p>There are many globally accessible LUA variables made available which reflext the configuration of SIPI and the state of the server and request. This variables a read only and created for every request.</p>"},{"location":"lua/#sipi-configuration-variables","title":"SIPI configuration variables","text":"<p>This variables are defined ither in the configuration file if SIPI, in environemt variables at startup or as command line option when starting the server.</p>"},{"location":"lua/#confighostname","title":"config.hostname","text":"<pre><code>config.hostname\n</code></pre> <p>The hostname  SIPI is configures to run on (see hostname in configuration description).</p>"},{"location":"lua/#configport","title":"config.port","text":"<pre><code>config.port\n</code></pre> <p>Portnumber where the SIPI server listens (see serverport in configuration description).</p>"},{"location":"lua/#configsslport","title":"config.sslport","text":"<pre><code>config.sslport\n</code></pre> <p>Portnumber for SSL connections of SIPI (see sslport in configuration description).</p>"},{"location":"lua/#configimgroot","title":"config.imgroot","text":"<pre><code>config.imgroot\n</code></pre> <p>Root directory for IIIF-served images (see imgroot in configuration description).</p>"},{"location":"lua/#configdocroot","title":"config.docroot","text":"<pre><code>config.docroot\n</code></pre> <p>Root directory for WEB-Server (see docroot in configuration description).</p>"},{"location":"lua/#configmax_temp_file_age","title":"config.max_temp_file_age","text":"<pre><code>config.max_temp_file_age\n</code></pre> <p>maximum age of temporary files (see max_temp_file_age in configuration description).</p>"},{"location":"lua/#configprefix_as_path","title":"config.prefix_as_path","text":"<pre><code>config.prefix_as_path`\n</code></pre> <p><code>true</code> if the prefix should be used as path info (see prefix_as_path in configuration description).</p>"},{"location":"lua/#configinit_script","title":"config.init_script","text":"<pre><code>config.init_script\n</code></pre> <p>Path to initialization script (see initscript in configuration description).</p>"},{"location":"lua/#configscriptdir","title":"config.scriptdir","text":"<pre><code>config.scriptdir\n</code></pre> <p>Path to script directory. (see scriptdir in configuration description).</p>"},{"location":"lua/#configcache_dir","title":"config.cache_dir","text":"<pre><code>config.cache_dir\n</code></pre> <p>Path to cache directory for iIIF served images. (see cachedir in configuration description).</p>"},{"location":"lua/#configcache_size","title":"config.cache_size","text":"<pre><code>config.cache_size\n</code></pre> <p>Maximal size of cache (see cachesize in configuration description).</p>"},{"location":"lua/#configcache_n_files","title":"config.cache_n_files","text":"<pre><code>config.cache_n_files\n</code></pre> <p>Maximal number of files in cache. (see cache_nfiles in configuration description).</p>"},{"location":"lua/#configcache_hysteresis","title":"config.cache_hysteresis","text":"<pre><code>config.cache_hysteresis\n</code></pre> <p>Amount of data to be purged if cache reaches maximum size. (see cache_hysteresis in configuration description).</p>"},{"location":"lua/#configjpeg_quality","title":"config.jpeg_quality","text":"<pre><code>config.jpeg_quality\n</code></pre> <p>Unfortunately, the IIIF Image API does not allow to give a JPEG quality (=compression) on the IIIF URL. SIPI allows to configure the compression quality system wide with this parameter. Allowed values are in he range [1..100] where 1 the worst quality (and highest compression factor = smallest file size) and 100 the highest quality (with lowest compression factor = biggest file size). Please note that SIPI is not able to provide lossless compression for JPEG files. (see jpeg_quality in configuration description).</p>"},{"location":"lua/#configkeep_alive","title":"config.keep_alive","text":"<pre><code>config.keep_alive\n</code></pre> <p>Maximal keep-alive time for HTTP requests that ask for a keep-alive connection. (see keep_alive in configuration description).</p>"},{"location":"lua/#configthumb_size","title":"config.thumb_size","text":"<pre><code>config.thumb_size\n</code></pre> <p>Default thumbnail image size. (see thumb_size in configuration description).</p>"},{"location":"lua/#confign_threads","title":"config.n_threads","text":"<pre><code>config.n_threads\n</code></pre> <p>Number of worker threads SIPI uses. (see nthreads in configuration description).</p>"},{"location":"lua/#configmax_post_size","title":"config.max_post_size","text":"<pre><code>config.max_post_size\n</code></pre> <p>Maximal size of POST data allowed (see max_post_size in configuration description).</p>"},{"location":"lua/#configtmpdir","title":"config.tmpdir","text":"<pre><code>config.tmpdir\n</code></pre> <p>Temporary directory to store uploads. (see tmpdir in configuration description).</p>"},{"location":"lua/#configssl_certificate","title":"config.ssl/_certificate","text":"<pre><code>config.ssl_certificate\n</code></pre> <p>Path to the SSL certificate that SIPI uses. (see ssl_certificate in configuration description).</p>"},{"location":"lua/#configssl_key","title":"config.ssl/_key","text":"<pre><code>config.ssl_key\n</code></pre> <p>Path to the SSL key that SIPI uses. (see ssl_key in configuration description).</p>"},{"location":"lua/#configlogfile","title":"config.logfile","text":"<pre><code>config.logfile\n</code></pre> <p>Name of the logfile. SIPI is currently using the built-in logger which logs to stdout and the logfile name is ignored.  (see logfile in configuration description).</p>"},{"location":"lua/#configloglevel","title":"config.loglevel","text":"<pre><code>config.loglevel\n</code></pre> <p>Indicates what should be logged. The variable contains a integer that corresponds to the syslog level. (see loglevel in configuration description).</p>"},{"location":"lua/#configadminuser","title":"config.adminuser","text":"<pre><code>config.adminuser\n</code></pre> <p>Name of admin user. (see user in configuration description).</p>"},{"location":"lua/#configpassword","title":"config.password","text":"<pre><code>config.password\n</code></pre> <p>Password (plain text, not encrypted) of admin user (use with caution)! (see password in configuration description).</p>"},{"location":"lua/#sipi-server-variables","title":"SIPI Server Variables","text":"<p>Sipi server variables are dependent on the incoming request and are created by SIPI automatically for each request.</p>"},{"location":"lua/#servermethod","title":"server.method","text":"<pre><code>server.method\n</code></pre> <p>The HTTP request method. Is one of <code>OPTIONS</code>, <code>GET</code>, <code>HEAD</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>TRACE</code>, <code>CONNECT</code> or <code>OTHER</code>.</p>"},{"location":"lua/#serverhas_openssl","title":"server.has_openssl","text":"<pre><code>server.has_openssl\n</code></pre> <p><code>true</code> if OpenSSL is available. This variable is determined compilation time. Usually SSL should be included, but SIPI can be compiled without SSL support. There is no option in the configuration file for this.</p>"},{"location":"lua/#serversecure","title":"server.secure","text":"<pre><code>server.secure\n</code></pre> <p><code>true</code> if the connection was made over HTTPS using SSL.</p>"},{"location":"lua/#serverhost","title":"server.host","text":"<pre><code>server.host\n</code></pre> <p>The hostname of the Sipi server that was used in the request.</p>"},{"location":"lua/#serverclient_ip","title":"server.client_ip","text":"<pre><code>server.client_ip\n</code></pre> <p>The IPv4 or IPv6 address of the client connecting to Sipi.</p>"},{"location":"lua/#serverclient_port","title":"server.client_port","text":"<pre><code>server.client_port\n</code></pre> <p>The port number of the client socket.</p>"},{"location":"lua/#serveruri","title":"server.uri","text":"<pre><code>server.uri\n</code></pre> <p>The URL path used to access Sipi (does not include the hostname).</p>"},{"location":"lua/#serverheader","title":"server.header","text":"<pre><code>server.header\n</code></pre> <p>A table containing all the HTTP request headers(in lowercase).</p>"},{"location":"lua/#servercookies","title":"server.cookies","text":"<pre><code>server.cookies\n</code></pre> <p>A table of the cookies that were sent with the request.</p>"},{"location":"lua/#serverget","title":"server.get","text":"<pre><code>server.get\n</code></pre> <p>A table of GET request parameters.</p>"},{"location":"lua/#serverpost","title":"server.post","text":"<pre><code>server.post\n</code></pre> <p>A table of POST or PUT request parameters.</p>"},{"location":"lua/#serverrequest","title":"server.request","text":"<pre><code>server.request\n</code></pre> <p>All request parameters.</p>"},{"location":"lua/#servercontent","title":"server.content","text":"<pre><code>server.content\n</code></pre> <p>If the request had a body, the variable contains the body data. Otherwise it's <code>nil</code>.</p>"},{"location":"lua/#servercontent_type","title":"server.content_type","text":"<pre><code>server.content_type\n</code></pre> <p>Returns the content type of the request. If there is no type or no content, this variable is <code>nil</code>.</p>"},{"location":"lua/#serveruploads","title":"server.uploads","text":"<pre><code>server.uploads\n</code></pre> <p>This is an array of upload parameters, one per file. Each one is a table containing:</p> <ul> <li><code>fieldname</code>: the name of the form field.</li> <li><code>origname</code>: the original filename.</li> <li><code>tmpname</code>: a temporary path to the uploaded file.</li> <li><code>mimetype</code>: the MIME type of the uploaded file as provided by the browser.</li> <li><code>filesize</code>: the size of uploaded file in bytes.</li> </ul> <p>The upload can be accessed as follows: <pre><code>for index, value in pairs(server.uploads) do\n    --\n    -- copy the uploaded file to the image repository using the original name\n    --\n    server.copyTmpfile(index, config.imgdir .. '/' .. value[\"origname\"])\nend\n</code></pre></p>"},{"location":"lua/#knora-specific-variables","title":"Knora-specific variables","text":"<p>The development of SIPI came out of the need to have a flexible, high performance IIIF server for the Swiss National research infrastructure Data and Service Center for the Humanities (DaSCH). The aim of the DaSCH is to guarantee long-term accessibility of research data from the Humanities. The operates a specialized platform Knora. The following variables are for internal use only.</p>"},{"location":"lua/#configknora_path","title":"config.knora_path","text":"<pre><code>config.knora_path\n</code></pre> <p>Path to knora REST API (only for SIPI used with Knora)</p>"},{"location":"lua/#configknora_port","title":"config.knora_port","text":"<pre><code>config.knora_port\n</code></pre> <p>Port that the Knora API uses</p>"},{"location":"lua/#sipi-functions-available-to-lua-scripts","title":"SIPI functions available to Lua scripts","text":"<p>Sipi provides the following functions that can be called from Lua scripts. Each function returns two values. The first value is <code>true</code> if the operation succeeded, <code>false</code> otherwise. If the operation succeeded, the second value is the result of the operation, otherwise it is an error message.</p>"},{"location":"lua/#sipi-connection-functions","title":"SIPI Connection Functions","text":"<p>These LUA function alter the way the HTTP connection is handled.</p>"},{"location":"lua/#serversetbuffer","title":"server.setBuffer","text":"<pre><code>success, errmsg = server.setBuffer([bufsize][,incsize])\n</code></pre> <p>Activates the the connection buffer. Optionally the buffer size and increment size can be given. Returns <code>true, nil</code> on success or <code>false, errormsg</code> on failure.</p>"},{"location":"lua/#serversendheader","title":"server.sendHeader","text":"<pre><code>success, errormsg = server.sendHeader(key, value)\n</code></pre> <p>Sets an HTTP response header. Returns <code>true, nil</code> on success or <code>false, errormsg</code> on failure.</p>"},{"location":"lua/#serversendcookie","title":"server.sendCookie","text":"<pre><code>success, errormsg = server.sendCookie(key, value [, options-table])\n</code></pre> <p>Sets a cookie in the HTTP response. Returns <code>true, nil</code> on success or <code>false, errormsg</code> on failure. The optional <code>options-table</code> is a Lua table containing the following keys:</p> <ul> <li><code>path</code></li> <li><code>domain</code></li> <li><code>expires</code> (value in seconds)</li> <li><code>secure</code> (boolean)</li> <li><code>http_only</code> (boolean)</li> </ul>"},{"location":"lua/#serversendstatus","title":"server.sendStatus","text":"<pre><code>server.sendStatus(code)\n</code></pre> <p>Sends an HTTP status code. This function is always successful and returns nothing.</p>"},{"location":"lua/#serverprint","title":"server.print","text":"<pre><code>success, errormsg = server.print(values)\n</code></pre> <p>Prints variables and/or strings over the HTTP connection to the client that originated the request. Returns <code>true, nil</code> on success or <code>false, errormsg</code> on failure.</p>"},{"location":"lua/#serverrequireauth","title":"server.requireAuth","text":"<pre><code>success, table = server.requireAuth()\n</code></pre> <p>This function retrieves HTTP authentication data that was supplied after sending a <code>'WWW-Authenticate'</code>-header (e.g. by issuing a the following commands to enter the HTTP login dialog:</p> <pre><code>    server.setBuffer()\n    server.sendStatus(401);\n    server.sendHeader('WWW-Authenticate', 'Basic realm=\"Sipi\"')\n</code></pre> <p>It returns <code>true, table</code> on success or <code>false, errormsg</code> on failure. The result of the authorization is returned as table with the following elements:</p> <ul> <li><code>status</code>: Either <code>BASIC</code>, <code>BEARER</code>, <code>NOAUTH</code> (no authorization header) or <code>ERROR</code></li> <li><code>username</code>: A string containing the supplied username (only existing if stats is <code>BASIC</code>)</li> <li><code>password</code>: A string containing the supplied password (only existing if stats is <code>BASIC</code>)</li> <li><code>token</code>: A string containing the raw token information (only if status <code>BEARER</code>)</li> <li><code>message</code>: A string containing the error message (only if status <code>ERROR</code>)</li> </ul> <p>Example:</p> <pre><code>success, auth = server.requireAuth()\nif not success then\n    server.sendStatus(501)\n    server.print(\"Error in getting authentication scheme!\")\n    return -1\nend\n\nif auth.status == 'BASIC' then\n    --\n    -- everything OK, let's create the token for further\n    -- calls and ad it to a cookie\n    --\n    if auth.username == config.adminuser and\n       auth.password == config.password then\n        tokendata = {\n            iss = \"sipi.unibas.ch\",\n            aud = \"knora.org\",\n            user = auth.username\n        }\n        success, token = server.generate_jwt(tokendata)\n        if not success then\n            server.sendStatus(501)\n            server.print(\"Could not generate JWT!\")\n            return -1\n        end\n        success, errormsg = server.sendCookie('sipi',\n                                              token,\n                                              {path = '/', expires = 3600})\n        if not success then\n            server.sendStatus(501)\n            server.print(\"Couldn't send cookie with JWT!\")\n            return -1\n        end\n    else\n        server.sendStatus(401)\n        server.sendHeader('WWW-Authenticate', 'Basic realm=\"Sipi\"')\n        server.print(\"Wrong credentials!\")\n        return -1\n    end\nelseif auth.status == 'BEARER' then\n    success, jwt = server.decode_jwt(auth.token)\n    if not success then\n        server.sendStatus(501)\n        server.print(\"Couldn't deocde JWT!\")\n        return -1\n    end\n    if (jwt.iss ~= 'sipi.unibas.ch') or\n       (jwt.aud ~= 'knora.org') or\n       (jwt.user ~= config.adminuser) then\n        server.sendStatus(401)\n        server.sendHeader('WWW-Authenticate', 'Basic realm=\"Sipi\"')\n        return -1\n    end\nelseif auth.status == 'NOAUTH' then\n    server.setBuffer()\n    server.sendStatus(401);\n    server.sendHeader('WWW-Authenticate', 'Basic realm=\"Sipi\"')\n    return -1\nelse\n    server.status(401)\n    server.sendHeader('WWW-Authenticate', 'Basic realm=\"Sipi\"')\n    return -1\nend\n</code></pre>"},{"location":"lua/#sipi-file-system-function","title":"SIPI File System Function","text":"<p>These functions offer tools to manipuale files and directories, and to gather file information.</p>"},{"location":"lua/#serverfsftype","title":"server.fs.ftype","text":"<pre><code>success, filetype = server.fs.ftype(filepath)\n</code></pre> <p>Checks the filetype of a given filepath. Returns either <code>true, filetype</code> (with filetype one of <code>\"FILE\"</code>, <code>\"DIRECTORY\"</code>, <code>\"CHARDEV\"</code>, <code>\"BLOCKDEV\"</code>, <code>\"LINK\"</code>, <code>\"SOCKET\"</code> or <code>\"UNKNOWN\"</code>) or <code>false, errormsg</code>.</p>"},{"location":"lua/#serverfsmodtime","title":"server.fs.modtime","text":"<pre><code>success, modtime = server.fs.modtime(filepath)\n</code></pre> <p>Retrieves the last modification date of a file in seconds since epoch UTC. Returns either <code>true</code>, <code>modtime</code> or <code>false</code>, <code>errormsg</code>.</p>"},{"location":"lua/#serverfsis_readable","title":"server.fs.is_readable","text":"<pre><code>success, readable = server.fs.is_readable(filepath)\n</code></pre> <p>Checks if a file is readable. Returns <code>true, readable</code> (boolean) on success or <code>false, errormsg</code> on failure.</p>"},{"location":"lua/#serverfsis_writeable","title":"server.fs.is_writeable","text":"<pre><code>success, writeable = server.fs.is_writeable(filepath)\n</code></pre> <p>Checks if a file is writeable. Returns <code>true, writeable</code> (boolean) on success or <code>false, errormsg</code> on failure.</p>"},{"location":"lua/#serverfsis_executable","title":"server.fs.is_executable","text":"<pre><code>success, errormsg = server.fs.is_executable(filepath)\n</code></pre> <p>Checks if a file is executable. Returns <code>true, executable</code> (boolean) on success or <code>false, errormsg</code> on failure.</p>"},{"location":"lua/#serverfsexists","title":"server.fs.exists","text":"<pre><code>success, exists = server.fs.exists(filepath)\n</code></pre> <p>Checks if a file exists. Checks if a file exists. Returns <code>true, exists</code> (boolean) on success or <code>false, errormsg</code> on failure.</p>"},{"location":"lua/#serverfsunlink","title":"server.fs.unlink","text":"<pre><code>success, errormsg = server.fs.unlink(filename)\n</code></pre> <p>Deletes a file from the file system. The file must exist and the user must have write access. Returns <code>true, nil</code> on success or <code>false, errormsg</code> on failure.</p>"},{"location":"lua/#serverfsmkdir","title":"server.fs.mkdir","text":"<pre><code>success, errormsg = server.fs.mkdir(dirname, [tonumber('0755', 8)])\n</code></pre> <p>Creates a new directory, optionally with the specified permissions. Returns <code>true, nil</code> on success or <code>false, errormsg</code> on failure.</p>"},{"location":"lua/#serverfsrmdir","title":"server.fs.rmdir","text":"<pre><code>success, errormsg = server.fs.rmdir(dirname)\n</code></pre> <p>Deletes a directory. Returns <code>true, nil</code> on success or <code>false, errormsg</code> on failure.</p>"},{"location":"lua/#serverfsgetcwd","title":"server.fs.getcwd","text":"<pre><code>success, curdir = server.fs.getcwd()\n</code></pre> <p>Gets the current working directory. Returns <code>true, current_dir</code> on success or <code>false, errormsg</code> on failure.</p>"},{"location":"lua/#serverfsreaddir","title":"server.fs.readdir","text":"<pre><code>success, filenames = server.fs.readdir(dirname)\n</code></pre> <p>Gets the names of the files in a directory, not including <code>.</code> and <code>..</code>. Returns <code>true, table</code> on success or <code>false, errormsg</code> on failure.</p>"},{"location":"lua/#serverfschdir","title":"server.fs.chdir","text":"<pre><code>success, oldir = server.fs.chdir(newdir)\n</code></pre> <p>Change working directory. Returns <code>true, olddir</code> on success or <code>false, errormsg</code> on failure.</p>"},{"location":"lua/#serverfscopyfile","title":"server.fs.copyFile","text":"<pre><code>success, errormsg = server.fs.copyFile(source, destination)\n</code></pre> <p>Copies a file from source to destination. Returns <code>true, nil</code>on success or <code>false, errormsg</code> on failure.</p>"},{"location":"lua/#serverfsmovefile","title":"server.fs.moveFile","text":"<pre><code>success, errormsg = server.fs.moveFile(from, to)\n</code></pre> <p>Moves a file. The move connot cross filesystem boundaries! <code>true, nil</code>on success or <code>false, errormsg</code> on failure.</p>"},{"location":"lua/#other-helper-function","title":"Other Helper Function","text":""},{"location":"lua/#serverhttp","title":"server.http","text":"<pre><code>success, result = server.http(method, \"http://server.domain[:port]/path/file\" [, header] [, timeout])\n</code></pre> <p>Performs an HTTP request using curl. Currently implements only GET requests. Parameters:</p> <ul> <li><code>method</code>: The HTTP request method. Currently must be <code>\"GET\"</code>.</li> <li><code>url</code>: The HTTP URL.</li> <li><code>header</code>: An optional table of key-value pairs representing HTTP     request headers.</li> <li><code>timeout</code>: An optional number of milliseconds until the connection     times out.</li> </ul> <p>Authentication is not yet supported.</p> <p>The result is a table:</p> <pre><code>result = {\n    status_code = value -- HTTP status code returned\n    erromsg = \"error description\" -- only if success is false\n    header = {\n        name = value [, name = value, ...]\n    },\n    certificate = { -- only if HTTPS connection\n        subject = value,\n        issuer = value\n    },\n    body = data,\n    duration = milliseconds\n}\n</code></pre> <p>Example:</p> <pre><code>success, result = server.http(\"GET\", \"http://www.salsah.org/api/resources/1\", 100)\n\nif (result.success) then\n   server.print(\"&lt;table&gt;\")\n   server.print(\"&lt;tr&gt;&lt;th&gt;Field&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;&lt;/tr&gt;\")\n   for k,v in pairs(server.header) do\n       server.print(\"&lt;tr&gt;&lt;td&gt;\", k, \"&lt;/td&gt;&lt;td&gt;\", v, \"&lt;/td&gt;&lt;/tr&gt;\")\n   end\n   server.print(\"&lt;/table&gt;&lt;hr/&gt;\")\n\n   server.print(\"Duration: \", result.duration, \" ms&lt;br/&gt;&lt;hr/&gt;\")\n   server.print(\"Body:&lt;br/&gt;\", result.body)\nelse\n   server.print(\"ERROR: \", result.errmsg)\nend\n</code></pre>"},{"location":"lua/#servertable_to_json","title":"server.table_to_json","text":"<pre><code>success, jsonstr = server.table\\_to\\_json(table)\n</code></pre> <p>Converts a (nested) Lua table to a JSON string. Returns <code>true, jsonstr</code> on success or <code>false, errormsg</code> on failure.</p>"},{"location":"lua/#serverjson_to_table","title":"server.json_to_table","text":"<pre><code>success, table = server.json_to_table(jsonstr)\n</code></pre> <p>Converts a JSON string to a (nested) Lua table. Returns <code>true, table</code> on success or <code>false, errormsg</code> on failure.</p>"},{"location":"lua/#servergenerate_jwt","title":"server.generate_jwt","text":"<pre><code>success, token = server.generate_jwt(table)\n</code></pre> <p>Generates a JSON Web Token (JWT) with the supplied table as payload. Returns <code>true, token</code> on success or <code>false, errormsg</code> on failure. The internal may contain arbitrary keys and/or may contains the JWT claims as follows. (The type <code>IntDate</code> is a number of seconds since 1970-01-01T0:0:0Z):</p> <ul> <li><code>iss</code> (string =&gt; StringOrURI) OPT: principal that issued the JWT.</li> <li><code>exp</code> (number =&gt; IntDate) OPT: expiration time on or after which     the token MUST NOT be accepted for processing.</li> <li><code>nbf</code> (number =&gt; IntDate) OPT: identifies the time before which     the token MUST NOT be accepted for processing.</li> <li><code>iat</code> (number =&gt; IntDate) OPT: identifies the time at which the     JWT was issued.</li> <li><code>aud</code> (string =&gt; StringOrURI) OPT: identifies the audience that     the JWT is intended for. The audience value is a string, typically     the base address of the resource being accessed, such as     <code>https://contoso.com</code>.</li> <li><code>prn</code> (string =&gt; StringOrURI) OPT: identifies the subject of     the JWT.</li> <li><code>jti</code> (string =&gt; String) OPT: provides a unique identifier for     the JWT.</li> </ul>"},{"location":"lua/#serverdecode_jwt","title":"server.decode_jwt","text":"<pre><code>success, table = server.decode_jwt(token)\n</code></pre> <p>Decodes a JSON Web Token (JWT) and returns its content as table. Returns <code>true, table</code> on success or <code>false, errormsg</code> on failure.</p>"},{"location":"lua/#serverparse_mimetype","title":"server.parse_mimetype","text":"<pre><code>success, mimetype = server.parse_mimetype(str)\n</code></pre> <p>Parses a mimtype HTTP header string and returns a pair containing the actual mimetype and the charset used (if available). It returns <code>true, pair</code> with pair as mimetype and charset on success, <code>false, errormsg</code> on failure.</p>"},{"location":"lua/#serverfile_mimetype","title":"server.file_mimetype","text":"<pre><code>success, table = server.file_mimetype(path)\nsuccess, table = server.file_mimetype(index)\n</code></pre> <p>Determines the mimetype of a file. The first form is used if the file path is known. The second form can be used for uploads by passing the upload file index. It returns <code>true, table</code> on success or <code>false, errormsg</code> on failure. The table has 2 members: - <code>mimetype</code> - <code>charset</code></p>"},{"location":"lua/#serverfile_mimeconsistency","title":"server.file_mimeconsistency","text":"<pre><code>success, is_consistent = server.file_mimeconsistency(path)\nsuccess, is_consistent = server.file_mimeconsistency(index)\n</code></pre> <p>Checks if the file extension and the mimetype determined by the magic of the file is consistent. The first form requires a path (including the filename with extension), the second can be used for checking uploads by  passing the file index. It returns <code>true, is_consistent</code> on success or <code>false, errormsg</code> in case of an error. <code>is_consistent</code> is true if the mimetype corresponds to the file extension.</p>"},{"location":"lua/#servercopytmpfile","title":"server.copyTmpfile","text":"<pre><code>success, errormsg = server.copyTmpfile(from, to)\n</code></pre> <p>Sipi saves each uploaded file in a temporary location (given by the config variable <code>tmpdir</code>) and deletes it after the request has been served. This function is used to copy the file to another location where it can be retrieved later. Returns <code>true, nil</code> on success or <code>false, errormsg</code> on failure.</p> <p>Parameters:</p> <ul> <li><code>from</code>:    an index (integer value) of array server.uploads.</li> <li><code>target</code>:  destination path</li> </ul>"},{"location":"lua/#serversystime","title":"server.systime","text":"<pre><code>systime = server.systime()\n</code></pre> <p>Returns the current system time on the server in seconds since epoch.</p>"},{"location":"lua/#serverlog","title":"server.log","text":"<pre><code>server.log(message, loglevel)\n</code></pre> <p>Writes a message to the built-in logger. Severity levels are:</p> <ul> <li><code>server.loglevel.LOG_EMERG</code></li> <li><code>server.loglevel.LOG_ALERT</code></li> <li><code>server.loglevel.LOG_CRIT</code></li> <li><code>server.loglevel.LOG_ERR</code></li> <li><code>server.loglevel.LOG_WARNING</code></li> <li><code>server.loglevel.LOG_NOTICE</code></li> <li><code>server.loglevel.LOG_INFO</code></li> <li><code>server.loglevel.LOG_DEBUG</code></li> </ul>"},{"location":"lua/#serveruuid","title":"server.uuid","text":"<pre><code>success, uuid = server.uuid()\n</code></pre> <p>Generates a random UUID version 4 identifier in canonical form, as described in RFC 4122. Returns <code>true, uuid</code> on success or <code>false, errormsg</code> on failure.</p>"},{"location":"lua/#serveruuid62","title":"server.uuid62","text":"<pre><code>success, uuid62 = server.uuid62()\n</code></pre> <p>Generates a Base62-encoded UUID. Returns <code>true, uuid62</code> on success or <code>false, errormsg</code> on failure.</p>"},{"location":"lua/#serveruuid_to_base62","title":"server.uuid_to_base62","text":"<pre><code>success, uuid62 = server.uuid_to_base62(uuid)\n</code></pre> <p>Converts a canonical UUID string to a Base62-encoded UUID. Returns <code>true, uuid62</code> on success or <code>false, errormsg</code> on failure.</p>"},{"location":"lua/#serverbase62_to_uuid","title":"server.base62_to_uuid","text":"<pre><code>success, uuid = server.base62_to_uuid(uuid62)\n</code></pre> <p>Converts a Base62-encoded UUID to canonical form. Returns <code>true, uuid</code> on success or <code>false, errormsg</code> on failure.</p>"},{"location":"lua/#cache-management-functions","title":"Cache Management Functions","text":"<p>The following functions are available for managing the SIPI image cache from Lua scripts.</p>"},{"location":"lua/#cachesize","title":"cache.size","text":"<pre><code>success, size = cache.size()\n</code></pre> <p>Returns the current total size of cached files in bytes. Returns <code>nil</code> if no cache is configured.</p>"},{"location":"lua/#cachemax_size","title":"cache.max_size","text":"<pre><code>success, max = cache.max_size()\n</code></pre> <p>Returns the configured maximum cache size limit in bytes.</p>"},{"location":"lua/#cachenfiles","title":"cache.nfiles","text":"<pre><code>success, count = cache.nfiles()\n</code></pre> <p>Returns the current number of files in the cache.</p>"},{"location":"lua/#cachemax_nfiles","title":"cache.max_nfiles","text":"<pre><code>success, max = cache.max_nfiles()\n</code></pre> <p>Returns the configured maximum number of files allowed in cache.</p>"},{"location":"lua/#cachepath","title":"cache.path","text":"<pre><code>path = cache.path()\n</code></pre> <p>Returns the filesystem path to the cache directory, or <code>nil</code> if no cache is configured.</p>"},{"location":"lua/#cachefilelist","title":"cache.filelist","text":"<pre><code>filelist = cache.filelist([sortmethod])\n</code></pre> <p>Returns a table of cached files with metadata. The optional <code>sortmethod</code> parameter controls sorting:</p> <ul> <li><code>\"AT_ASC\"</code> \u2014 sort by access time, ascending</li> <li><code>\"AT_DESC\"</code> \u2014 sort by access time, descending</li> <li><code>\"FS_ASC\"</code> \u2014 sort by file size, ascending</li> <li><code>\"FS_DESC\"</code> \u2014 sort by file size, descending</li> </ul> <p>Each entry in the returned table contains:</p> Field Type Description <code>canonical</code> string Canonical cache key <code>origpath</code> string Original file path <code>cachepath</code> string Cache file path <code>size</code> integer File size in bytes <code>last_access</code> string Last access time (<code>\"YYYY-MM-DD HH:MM:SS\"</code>) <p>Returns <code>nil</code> if no cache is configured.</p>"},{"location":"lua/#cachedelete","title":"cache.delete","text":"<pre><code>success = cache.delete(canonical)\n</code></pre> <p>Deletes a specific cached file by its canonical key. Returns <code>true</code> on success, <code>false</code> otherwise.</p>"},{"location":"lua/#cachepurge","title":"cache.purge","text":"<pre><code>count = cache.purge()\n</code></pre> <p>Purges cache entries based on configured purge criteria (LRU). Returns the number of files purged, or <code>nil</code> if no cache is configured.</p>"},{"location":"lua/#filesystem-helper-functions","title":"Filesystem Helper Functions","text":"<p>The <code>server.fs</code> table provides filesystem operations. All functions return <code>(true, result)</code> on success or <code>(false, error_message)</code> on failure.</p>"},{"location":"lua/#serverfsexists_1","title":"server.fs.exists","text":"<pre><code>success, exists = server.fs.exists(filepath)\n</code></pre> <p>Check if a file or directory exists. Returns <code>true/false</code> for the existence check.</p>"},{"location":"lua/#serverfsftype_1","title":"server.fs.ftype","text":"<pre><code>success, filetype = server.fs.ftype(filepath)\n</code></pre> <p>Get the type of a path. Returns one of: <code>\"FILE\"</code>, <code>\"DIRECTORY\"</code>, <code>\"CHARDEV\"</code>, <code>\"BLOCKDEV\"</code>, <code>\"LINK\"</code>, <code>\"FIFO\"</code>, <code>\"SOCKET\"</code>, <code>\"UNKNOWN\"</code>.</p>"},{"location":"lua/#serverfsmodtime_1","title":"server.fs.modtime","text":"<pre><code>success, timestamp = server.fs.modtime(filepath)\n</code></pre> <p>Get the modification time of a file as a Unix timestamp (seconds since epoch).</p>"},{"location":"lua/#serverfsreaddir_1","title":"server.fs.readdir","text":"<pre><code>success, filenames = server.fs.readdir(dirpath)\n</code></pre> <p>List all files and directories in a directory. Returns a Lua table of filenames (excludes <code>.</code> and <code>..</code>).</p>"},{"location":"lua/#serverfsis_readable_1","title":"server.fs.is_readable","text":"<pre><code>success, readable = server.fs.is_readable(filepath)\n</code></pre> <p>Check if a file is readable by the current process.</p>"},{"location":"lua/#serverfsis_writeable_1","title":"server.fs.is_writeable","text":"<pre><code>success, writeable = server.fs.is_writeable(filepath)\n</code></pre> <p>Check if a file is writable by the current process.</p>"},{"location":"lua/#serverfsis_executable_1","title":"server.fs.is_executable","text":"<pre><code>success, executable = server.fs.is_executable(filepath)\n</code></pre> <p>Check if a file is executable by the current process.</p>"},{"location":"lua/#serverfsunlink_1","title":"server.fs.unlink","text":"<pre><code>success, errmsg = server.fs.unlink(filepath)\n</code></pre> <p>Delete a file from the filesystem.</p>"},{"location":"lua/#serverfsmkdir_1","title":"server.fs.mkdir","text":"<pre><code>success, errmsg = server.fs.mkdir(dirname, mode)\n</code></pre> <p>Create a new directory. <code>mode</code> is a Unix permission integer (e.g., <code>tonumber('0755', 8)</code>).</p>"},{"location":"lua/#serverfsrmdir_1","title":"server.fs.rmdir","text":"<pre><code>success, errmsg = server.fs.rmdir(dirname)\n</code></pre> <p>Remove an empty directory.</p>"},{"location":"lua/#serverfsgetcwd_1","title":"server.fs.getcwd","text":"<pre><code>success, cwd = server.fs.getcwd()\n</code></pre> <p>Get the current working directory.</p>"},{"location":"lua/#serverfschdir_1","title":"server.fs.chdir","text":"<pre><code>success, old_dir = server.fs.chdir(newdir)\n</code></pre> <p>Change the current working directory. Returns the previous working directory on success.</p>"},{"location":"lua/#serverfscopyfile_1","title":"server.fs.copyFile","text":"<pre><code>success, errmsg = server.fs.copyFile(source, target)\n</code></pre> <p>Copy a file from source to target.</p>"},{"location":"lua/#serverfsmovefile_1","title":"server.fs.moveFile","text":"<pre><code>success, errmsg = server.fs.moveFile(source, target)\n</code></pre> <p>Move/rename a file. <code>source</code> can be a file path (string) or an uploaded file index (integer, 1-based).</p>"},{"location":"lua/#server-request-properties","title":"Server Request Properties","text":"<p>The following read-only properties are available on the <code>server</code> table within request handlers:</p> Property Type Description <code>server.method</code> string HTTP method: <code>\"GET\"</code>, <code>\"POST\"</code>, <code>\"PUT\"</code>, <code>\"DELETE\"</code>, <code>\"HEAD\"</code>, <code>\"OPTIONS\"</code> <code>server.uri</code> string The complete request URI/path <code>server.host</code> string The Host header value <code>server.client_ip</code> string Client's IP address <code>server.client_port</code> integer Client's port number <code>server.secure</code> boolean Whether the connection is HTTPS <code>server.has_openssl</code> boolean Whether OpenSSL is available <code>server.route</code> string The matched route (if using routing) <code>server.content</code> string Raw POST/PUT body content <code>server.content_type</code> string Content-Type header value <code>server.docroot</code> string Document root path"},{"location":"lua/#request-data-tables","title":"Request Data Tables","text":"Property Type Description <code>server.header</code> table HTTP request headers (name-value pairs) <code>server.cookies</code> table Cookie name-value pairs <code>server.get</code> table URL query parameters <code>server.post</code> table POST form parameters <code>server.request</code> table Path parameters"},{"location":"lua/#uploaded-files","title":"Uploaded Files","text":"<p><code>server.uploads</code> is a table of uploaded files (1-based indexing). Each entry contains:</p> Field Type Description <code>fieldname</code> string Form field name <code>origname</code> string Original filename <code>tmpname</code> string Temporary file path on server <code>mimetype</code> string MIME type of the uploaded file <code>filesize</code> integer File size in bytes"},{"location":"lua/#additional-server-functions","title":"Additional Server Functions","text":""},{"location":"lua/#serversetbuffer_1","title":"server.setBuffer","text":"<pre><code>success, errmsg = server.setBuffer([bufsize], [incsize])\n</code></pre> <p>Enable response buffering with optional buffer size and increment size (in bytes).</p>"},{"location":"lua/#serversendcookie_1","title":"server.sendCookie","text":"<pre><code>success, errmsg = server.sendCookie(name, value [, options])\n</code></pre> <p>Set a cookie in the HTTP response. The optional <code>options</code> table can contain:</p> Key Type Description <code>path</code> string Cookie path <code>domain</code> string Cookie domain <code>expires</code> integer Expiration (seconds since epoch) <code>secure</code> boolean Secure flag <code>http_only</code> boolean HTTP-only flag"},{"location":"lua/#serverrequireauth_1","title":"server.requireAuth","text":"<pre><code>auth = server.requireAuth()\n</code></pre> <p>Parse authentication information from the request. Returns a table with:</p> Field Type Description <code>status</code> string <code>\"NOAUTH\"</code>, <code>\"BASIC\"</code>, <code>\"BEARER\"</code>, or <code>\"ERROR\"</code> <code>username</code> string Username (BASIC auth only) <code>password</code> string Password (BASIC auth only) <code>token</code> string Bearer token (BEARER auth only) <code>message</code> string Error message (ERROR status only)"},{"location":"lua/#utility-functions","title":"Utility Functions","text":""},{"location":"lua/#helperfilename_hash","title":"helper.filename_hash","text":"<pre><code>success, hashed_path = helper.filename_hash(filename)\n</code></pre> <p>Convert a filename into a hashed filesystem path, using SIPI's internal hash algorithm for cache file organization.</p>"},{"location":"lua/#installing-lua-modules","title":"Installing Lua modules","text":"<p>To install Lua modules that can be used in Lua scripts, use <code>local/bin/luarocks</code>. Make sure that the location where the modules are stored is in the Lua package path, which is printed by local/bin/lurocks path. The Lua paths will be used by the Lua interpreter when loading modules in a script with <code>require</code> (see Using LuaRocks to install packages in the current directory).</p> <p>For example, using <code>local/bin/luarocks install --local package</code>, the package will be installed in <code>~/.luarocks/</code>. To include this path in the Lua's interpreter package search path, you can use an environment variable. Running <code>local/bin/luarocks path</code> outputs the code you can use to do so. Alternatively, you can build the package path at the beginning of a Lua file by setting <code>package.path</code> and <code>package.cpath</code> (see Running scripts with packages).</p>"},{"location":"lua/lua-image/","title":"Lua image functions","text":"<p>Through Lua scripting, SIPI allows a wide area of utilities to analyze, manipulate and convert images to/from different formats. This functionality allows to use SIPI e.g. for offering image upload and converting these images into IIIF conformant long-term storage formats (e.g. JPEG2000). It allows to programmatically modify an image before delivering it to the client, or to extract data from the images.</p> <p>The basic concept is a specialized Lua image object that offers all methods to manipulate images.</p>"},{"location":"lua/lua-image/#sipiimagenewfilename","title":"SipiImage.new(filename)","text":"<p>This method creates a new image object by reading an image file that has to be located somewhere on the SIPI server.</p> <p>The simple forms are:</p> <pre><code>img = SipiImage.new(\"filepath\")\nimg = SipiImage.new(index)\n</code></pre> <p>The first variant opens a file given by \"filepath\", the second variant opens an uploaded file directly using the integer index to the uploaded files.</p> <p>If the index of an uploaded file is passed as an argument, this method adds additional metadata to the <code>SipiImage</code> object that is constructed: the file's original name, its MIME type, and its SHA256 checksum. When the <code>SipiImage</code> object is then written to another file, this metadata will be stored in an extra header record.</p> <p>If a filename is passed, the method does not add this metadata.</p> <p>The more complex form is as follows:</p> <pre><code>img = SipiImage.new(\"filename\", {\n        region=&lt;iiif-region-string&gt;,\n        size=&lt;iiif-size-string&gt;,\n        reduce=&lt;integer&gt;,\n        original=origfilename,\n        hash=\"md5\"|\"sha1\"|\"sha256\"|\"sha384\"|\"sha512\"\n      })\n</code></pre> <p>This creates a new Lua image object and loads the given image into. The second form allows to indicate a region, the size or a reduce factor and the original filename. The <code>hash</code> parameter indicates that the given checksum should be calculated out of the pixel values and written into the header. All parameters are optional, but at least one has to given. The meaning of the parameters are:</p> <ul> <li><code>region</code>: A region in IIIF format the image should be cropped to.</li> <li><code>size</code>: The size of the resulting image as valid IIIF size string.</li> <li><code>reduce</code>: An much faster alternative to size, if the image size will be   reduced by a integer factor (2=half size, 3=one third size etc.)</li> <li><code>original</code>: The original file name that should be recorded in the metadata</li> <li><code>hash</code>: The Hash algorithm that will be used for the hash of the pixel values. Valid   entries are <code>md5</code>, <code>sha1</code>, <code>sha256</code>, <code>sha384</code> and <code>sha512</code>.</li> </ul> <p>For example to read an image and include the SIPI preservation metadata, the function is called as follows:</p> <pre><code>SipiImage.new(\"path_to_file\", { original=\"my_image.tif\", hash=\"md5\" }\n</code></pre> <p>This call will include the preservation metadata (please note that in this case the original filename is mandatory, since Lua has know direct knowledge about the original filename. The filepath given as first parameter must not and normally does not correspond to the original filename). The <code>hash</code>-parameter indicates to use the md5-algorithm for the has of the pixel values.</p>"},{"location":"lua/lua-image/#sipiimagedims","title":"SipiImage.dims()","text":"<pre><code>  success, dims = img.dims()\n  if success then\n      server.print('nx=', dims.nx, ' ny=', dims.ny, ' ori=', dims.orientation)\n  end\n</code></pre> <p>This method returns basic information about the image. It returns a Lua table withg the following items: - nx: Number of pixels in X direction (image width) - ny: Number of pixels in Y direction (image height) - orientation: Orientation of image which is an integer with the following meaning:   - 1: (TOPLEFT) The 0th row represents the visual top of the image, and the 0th column represents the visual left-hand side.   - 2: (TOPRIGHT) The 0th row represents the visual top of the image, and the 0th column represents the visual right-hand side.   - 3: (BOTRIGHT) The 0th row represents the visual bottom of the image, and the 0th column represents the visual right-hand side.   - 4: (BOTLEFT) The 0th row represents the visual bottom of the image, and the 0th column represents the visual left-hand side.   - 5: (LEFTTOP) The 0th row represents the visual left-hand side of the image, and the 0th column represents the visual top.   - 6: (RIGHTTOP) The 0th row represents the visual right-hand side of the image, and the 0th column represents the visual top.   - 7: (RIGHTBOT) The 0th row represents the visual right-hand side of the image, and the 0th column represents the visual bottom.   - 8: (LEFTBOT) The 0th row represents the visual left-hand side of the image, and the 0th column represents the visual bottom.</p>"},{"location":"lua/lua-image/#sipiimageexifexif-parameter-name","title":"SipiImage.exif(&lt;EXIF-parameter-name&gt;)","text":"<pre><code>success, value-or-errormsg = img:exit(&lt;EXIF-parameter-name&gt;)\n</code></pre> <p>Return the value of an exif parameter. The following EXIF parameters are supported: - \"Orientation\": Orientation (integer) - \"Compression\": Compression method (integer) - \"PhotometricInterpretation\": The photometric interpretation (integer) - \"SamplesPerPixel\": Samples per pixel (integer) - \"ResolutionUnit\": 1=none, 2=inches, 3=cm (integer) - \"PlanarConfiguration\": Planar configuration, 1=chunky, 2=planar (integer) - \"DocumentName\": Document name (string) - \"Make\": Make of camera or scanner (string) - \"Model\": Model of camera or scanner (string) - \"Software\": Software used for capture (string) - \"Artist\": Artist that created the image (string) - \"DateTime\": Date and time of creation (string) - \"ImageDescription\": Image description - \"Copyright\": Copyright info - </p>"},{"location":"lua/lua-image/#sipiimagecropiiif-region-string","title":"SipiImage.crop(&lt;iiif-region-string&gt;)","text":"<pre><code>success, errormsg = img.crop(&lt;IIIF-region-string&gt;)\n</code></pre> <p>Crops the image to the given rectangular region. The parameter must be a valid IIIF-region string.</p>"},{"location":"lua/lua-image/#sipiimagescaleiiif-size-string","title":"SipiImage.scale(&lt;iiif-size-string&gt;)","text":"<pre><code>success, errormsg = img.scale(&lt;iiif-size-string&gt;)\n</code></pre> <p>Resizes the image to the given size as IIIF-conformant size string.</p>"},{"location":"lua/lua-image/#sipiimagerotateiiif-rotation-string","title":"SipiImage.rotate(&lt;iiif-rotation-string&gt;)","text":"<pre><code>success, errormsg = img.rotate(&lt;iiif-rotation-string&gt;)\n</code></pre> <p>Rotates and/or mirrors the image according the given iiif-conformant rotation string.</p>"},{"location":"lua/lua-image/#sipiimagetopleft","title":"SipiImage.topleft()","text":"<p>Rotates an image to the standard TOPLEFT orientation if necessary. Please note that viewers using tiling (e.g. openseadragon) require images in TOPLEFT rotation. Thus, it is highly recommended that all images served by SIPI IIIF will be set to TOPLEFT orientation. This process may involve rotation of 90, 180 or 270 degrees and possible mirroring which does not change the pixel values through interpolation.</p>"},{"location":"lua/lua-image/#sipiimagewatermarkwm-file-path","title":"SipiImage.watermark(wm-file-path)","text":"<pre><code>success, errormsg = img.watermark(wm-file-path)\n</code></pre> <p>Applies the given watermark file to the image. The watermark file must be a single channel 8-Bit gray value TIFF file.</p>"},{"location":"lua/lua-image/#sipiimagewritefilepath-compression_params","title":"SipiImage.write(filepath, [compression_params])","text":"<pre><code>success, errormsg = img.write(filepath)\nsuccess, errormsg = img.write('HTTP.jpg')\n</code></pre> <p>The first version write the image to a file in the SIPI server, the second writes the file to the HTTP connection (which is done whenever the basename of the output file is <code>HTTP</code>):</p> <p>Parameters:</p> <ul> <li> <p><code>filepath</code>: Path to output file. The file format is determined by the filename extension. Supported are</p> <ul> <li><code>jpg</code> : writes a JPEG file</li> <li><code>tif</code> : writes a TIFF file</li> <li><code>png</code> : writes a PNG file</li> <li><code>jpx</code> : writes a JPEG2000 file</li> <li><code>webp</code> : writes a WebP file</li> <li><code>gif</code> : writes a GIF file</li> <li><code>pdf</code> : writes a PDF file</li> </ul> </li> <li> <p><code>compression_params</code>: (optional) An optional Lua table with compression parameters (which are dependent on the   chosen output file format!) can be given. All compression parameters are optional. But if a compression parameter   table is give, it must have at least one entry.</p> </li> <li>JPEG format:<ul> <li><code>quality</code>: Number between 1 and 100 (1 highest compression, worst quality, 100 lowest compression, best quality)      </li> </ul> </li> <li>JPEG2000 format:<ul> <li><code>Sprofile</code>: Any of <code>PROFILE0</code>, <code>PROFILE1</code>, <code>PROFILE2</code>, <code>PART2</code>, <code>CINEMA2K</code>, <code>CINEMA4K</code>, <code>BROADCAST</code>,   <code>CINEMA2S</code>, <code>CINEMA4S</code>, <code>CINEMASS</code>, <code>IMF</code>. Defaults to <code>PART2</code>.</li> <li><code>Creversible</code>: Use the reversible compression algorithms of JPEG2000. Must be string <code>yes</code> or <code>no</code>. Defaults       to <code>yes</code>.</li> <li><code>Clayers</code>: Number of layers to use.</li> <li><code>Clevels</code>: Number of levels to use.</li> <li><code>Corder</code>: Ordering of file components. Must be one of the following strings: <code>LRCP</code>, <code>RLCP</code>, <code>RPCL</code>, <code>PCRL</code> or   <code>CPRL</code>.</li> <li><code>Cprecincts</code>: A kakadu conformant precinct string.</li> <li><code>rates</code>: rates string as used in kakadu.</li> </ul> </li> </ul>"},{"location":"lua/lua-image/#sipiimagesendformat","title":"SipiImage.send(format)","text":"<pre><code>success, errormsg = img.send(format)\n</code></pre> <p>Sends the file to the HTTP connection. Supported format strings:</p> <ul> <li><code>jpg</code> : sends a JPEG file</li> <li><code>tif</code> : sends a TIFF file</li> <li><code>png</code> : sends a PNG file</li> <li><code>jpx</code> : sends a JPEG2000 file</li> <li><code>webp</code> : sends a WebP file</li> <li><code>gif</code> : sends a GIF file</li> </ul>"},{"location":"lua/lua-image/#sipiimagemimetype_consistencymimetype-filename","title":"SipiImage.mimetype_consistency(mimetype, filename)","text":"<pre><code>success, consistent = img:mimetype_consistency(mimetype, original_filename)\n</code></pre> <p>This method checks if the supplied MIME type (e.g. received from the browser during upload), the file's magic number (file signature), and the file extension are consistent.</p> <p>Parameters:</p> <ul> <li><code>mimetype</code> (string): The expected MIME type (e.g., <code>\"image/tiff\"</code>).</li> <li><code>original_filename</code> (string): The original filename with extension (e.g., <code>\"photo.tif\"</code>).</li> </ul> <p>Returns: <code>(true, boolean)</code> on success where the boolean indicates consistency, or <code>(false, error_message)</code> on failure.</p> <p>Please note that MIME type handling can be quite complex, since the correspondence between file extensions and MIME types is not unambiguous. In addition the file signature cannot identify all MIME types. For example, a \"comma separated values\" file (extension <code>.csv</code>) can have a MIME type of <code>application/csv</code>, <code>text/csv</code>, <code>text/x-csv</code>, <code>application/vnd.ms-excel</code> and more. However, the file signature will usually return <code>text/plain</code>. SIPI tries to cope with these ambiguities.</p>"},{"location":"lua/lua-image/#example-image-processing-pipeline","title":"Example: Image Processing Pipeline","text":"<pre><code>-- Read an image, crop, scale, rotate, and write to a new format\nimg = SipiImage.new(\"input.tif\")\nimg:crop(\"100,100,500,500\")\nimg:scale(\"400,\")\nimg:rotate(\"90\")\nimg:write(\"output.jpx\")\n</code></pre> <pre><code>-- Process an uploaded file and send the result via HTTP\nimg = SipiImage.new(1)  -- first uploaded file\nimg:topleft()\nimg:scale(\"!800,800\")\nimg:send(\"jpg\")\n</code></pre>"},{"location":"lua/sqlite/","title":"Using SQLite in SIPI","text":"<p>Sipi supports SQLite 3 databases, which can be accessed from Lua scripts. You should use pcall to handle errors that may be returned by SQLite.</p>"},{"location":"lua/sqlite/#opening-an-sqlite-database","title":"Opening an SQLite Database","text":"<pre><code>db = sqlite(path_to_db, access)\n</code></pre> <p>This creates a new opaque database object. The parameters are:</p> <ul> <li><code>path_to_db</code>: path to the sqlite3 database file.</li> <li><code>access</code>: Method of opening the database. Allowed are<ul> <li><code>'RO'</code>: readonly access. The file must exist and the SPIP server must have read access to it.</li> <li><code>'RW'</code>: read and write access. The file must exist and the SPIP server must have read/write access to it.</li> <li><code>'CRW'</code>: If the database file does not exist, it will be created and opened with read/write access.</li> </ul> </li> </ul> <p>To destroy the database object and free all resources, you can do this:</p> <pre><code>db = ~db\n</code></pre> <p>However, Lua's garbage collection will destroy the database object and free all resources when they are no longer used.</p>"},{"location":"lua/sqlite/#preparing-a-query","title":"Preparing a Query","text":"<p>The SIPI sqlite interface supports direct queries as well as prepared statements. A direct query is constructed as follows:</p> <pre><code>qry = db &lt;&lt; 'SELECT * FROM image'\n</code></pre> <p>Or, if you want to use a prepared query statement:</p> <pre><code>qry = db &lt;&lt; 'INSERT INTO image (id, description) VALUES (?,?)'\n</code></pre> <p>The result of the <code>&lt;&lt;</code> operator (<code>qry</code>) will then be a query object containing a prepared query. If the query object is not needed anymore, it may be destroyed:</p> <pre><code>qry = ~qry\n</code></pre> <p>Query objects should be destroyed explicitly if not needed any longer.</p>"},{"location":"lua/sqlite/#executing-a-query","title":"Executing a Query","text":"<p>Excuting (calling) a query objects gets the next row of data. If there are no more rows, <code>nil</code> is returned. The row is returned as array of values.</p> <pre><code>row = qry()\nwhile (row) do\n    print(row[0], ' -&gt; ', row[1])\n    row = qry()\nend\n</code></pre> <p>Or with a prepared statement:</p> <pre><code>row = qry('SGV_1960_00315', 'This is an image of a steam engine...')\n</code></pre> <p>The second way is used for prepared queries that contain parameters.</p>"},{"location":"release-notes/","title":"Release Notes","text":"<p>Release notes are maintained on GitHub:</p> <ul> <li>CHANGELOG.md \u2014 Full changelog (auto-generated by release-please)</li> <li>GitHub Releases \u2014 Release artifacts and summaries</li> <li>Docker Hub \u2014 Published container images</li> </ul>"}]}